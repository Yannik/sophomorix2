#!/usr/bin/perl -w
# $Id$
# This script (sophomorix-janitor) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@gmx.de


# ===========================================================================
# Bibliotheken
# ===========================================================================
use strict;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixConfig;
use Sophomorix::SophomorixBase;
use Sophomorix::SophomorixAPI;
use Sophomorix::SophomorixPgLdap;
use Time::Local;
use Time::localtime;
use Term::ANSIColor qw(:constants); # farbiger Text RED, BLUE, ...
use Date::Calc qw(check_date);

use DBI;
use Net::LDAP;

use File::Find;

use File::Basename;

my @arguments = @ARGV;

# Scriptname ermitteln
my @list = split(/\//,$0);
my $scriptname = pop @list;

# nach jedem Printbefehl wieder auf Standardfarbe zurücksetzen
$Term::ANSIColor::AUTORESET = 1;
#use Sophomorix::SophomorixPgLdap qw(get_sys_users
#                                   );

# ===========================================================================
# Optionen verarbeiten
# ==========================================================================
$Conf::log_level=1;
my $help=0;
my $info=0;
my $login="";
my $uid=0;
my $listfiles=0;
my $list_db_junk=0;
my $kill_db_junk=0;

my $list_foreign_files=0;
my $check_horde=0;



my @userlist=();
my $classes="";
my $projects="";
my $student=0;
my $teacher=0;
my $administrator=0;
my $rooms="";
my $ws=0;
my $check=1;



# ???????
my $list_files_path="/var/log/sophomorix/list_files";
system("mkdir -p $list_files_path");

# Parsen der Optionen
my $testopt=GetOptions(
           "verbose|v+" => \$Conf::log_level,
           "user|users|u=s" => \$login,
           "class|classes|c=s" => \$classes,
           "project|projects|p=s" => \$projects,
           "student|students|s" => \$student,
           "teacher|teachers|t" => \$teacher,
           "administrator|administrators" => \$administrator,
           "room|rooms|r=s" => \$rooms,
           "workstations|workstation|w" => \$ws,
           "uid=i" => \$uid,
           "list-db-junk" => \$list_db_junk,
           "kill-db-junk" => \$kill_db_junk,
           "list-foreign-files" => \$list_foreign_files,
           "check-horde" => \$check_horde,
           "info|i" => \$info,
           "help|h" => \$help,
          );

# Prüfen, ob Optionen erkannt wurden
&check_options($testopt);

# --help
if ($help==1) {
   # Befehlbeschreibung
   print "\n$scriptname does some housekeeping:\n";

   print('
Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose

Housekeeping the postgres database ldap:

  --list-db-junk
  --kill-db-junk

Working on users files:

  --listfiles --user name (tut nicht!)
  --listfiles --uid uidnumber (tut nicht) 

  --list-foreign-files (List files/dirs in home of user, that are not owned by user)

  --check-horde (checks horde3 database (Table horde_prefs) for obsolete entries)

Selecting users (Default is: no user)
  -s / --students
  --class teachers  (teachers)
  -w / --workstations
  -u user1,user2,...   /  --users user1,user2,...
  -c class1,class2,... /  --class class1,class2,... 
  -p project1,project2,... /  --project project1,project2,... 
  -r room1,room2,...   /  --room room1,room2,...


Please see the sophomorix-janitor(8) man pages for full documentation
');
   print "\n";
   exit;
}



# ===========================================================================
# script starts here
# ===========================================================================


# userlist according to options
@userlist=&create_userlist($login,$classes,0,$projects,0,$student,
                               $rooms,$ws,$administrator,$check);

# --info
if ($info==1){
    foreach my $login (@userlist){
        print "$login\n";
    }
    exit;
}



# --list-db-junk / --kill-db-junk
if ($list_db_junk==1 or $kill_db_junk==1){
    print "Analyzing ldap database ...\n";
#    &check_connections();
    my $dbh=&db_connect();

    # TEST 1
    print "TEST 1: gids in project_groups must be existing\n";
    my %gid_db=();
    my @gid_db=();
    my $sth= $dbh->prepare( "SELECT projectid,membergid from project_groups" );
    $sth->execute();
    my $array_ref = $sth->fetchall_arrayref();
    foreach my $row (@$array_ref){
        # split the array, to give better names
        my ($project_id,$gid)=@$row;
        if (not exists $gid_db{$gid}){
            $gid_db{$gid}="seen";
            push @gid_db, $gid;
        }
        #print "   * $gid (project id: $project_id)\n";
    }
    @gid_db = sort @gid_db;
    # test it
    foreach my $gidnumber_test (@gid_db){
        print "* Testing gid $gidnumber_test:\n";
        # fetching gidname
        my ($gid)= $dbh->selectrow_array( "SELECT gid 
                                           FROM groups 
                                           WHERE gidnumber='$gidnumber_test'
                                          ");
        if (defined $gid){
            print "    $gidnumber_test is group $gid\n";
        } else {
            print "    $gidnumber_test is a nonexisting group\n";
            # DELETE
            my $sql="DELETE FROM project_groups WHERE membergid=$gidnumber_test";
            print "  Suggested action for $gidnumber_test:\n";
            print "  $sql\n";
            if ($kill_db_junk==1){
                print "  Do you want to delete $gidnumber_test with the SQL command? y/n\n";
                my $do_it=<>;
                chomp($do_it);
                if($do_it eq "y"){
                   $dbh->do($sql);

                } else {
                    print "Skipping deletion of group $gidnumber_test\n";
                }
            }
        }
    }
    # TEST 2
    # follows here


    &db_disconnect($dbh);
    exit;
}





# --list-foreign-files
if ($list_foreign_files==1){
    foreach my $login (@userlist){
        my ($home) = &fetchdata_from_account($login);
        #print "Looking for foreign files of $login in $home ...\n";
        my $prune= "-path $home/${Language::to_handoutcopy_dir} -prune -o".
                  " -path $home/${Language::share_dir} -prune -o".
                  " -path $home/${Language::handoutcopy_dir} -prune -o".
                  " -path $home/${Language::collect_dir} -prune -o".
                  " -path $home/${Language::collected_dir} -prune -o".
                  " -path $home/${Language::task_dir} -prune -o". 
                  " -path $home/${Language::inspection_dir} -prune -o". 
                  " -path $home/${Language::handout_dir} -prune -o".
      	      #    " -path $home/${Language::user_attic}/mailsync -prune -o".
      	          " -path $home/.Trash-* -prune -o";
        system ("find $home $prune ! -user $login -printf \"%u\t%g\t%p\n\"");
    }
    exit;
}

# --check-horde
if ($check_horde==1){
    my %horde_users=();
    my $database="horde";
    my $hostname="localhost";
    my $password=&get_horde_password();

    my $dsn = "DBI:mysql:database=$database;host=$hostname";
    my $dbh = DBI->connect($dsn, "horde",$password);
    print "Checking horde database for obsolete stuff\n";
    my $sth = $dbh->prepare( "SELECT pref_uid FROM horde_prefs");

    $sth->execute();
    my $array_ref = $sth->fetchall_arrayref();
    foreach my $row (@$array_ref){
	my ($uid)=@$row;
        $horde_users{$uid}="seen";
	#print "$uid\n";
    }


    while(my ($uid, $value) = each(%horde_users)) {
	my $return=system("id $uid > /dev/null");
        if ($return!=0){
        print "id returned $return\n";
        print "  User $uid ninexisting in system\n"; 
       }
    }

    $dbh->disconnect();
    exit;
}



# ===========================================================================
# list files and do something
# ===========================================================================
my @dirs=("/home/students/");

if ($uid==0 and $login ne ""){
    # fetch uid of name
    my ($name, $pass, $uid_of_user, $gid)= getpwnam($login);
    if (not defined $uid_of_user){
        print "ERROR: Could not determine uid of user $login\n";
        print "       Please specify a uid\n\n";
        exit;
    } else {
        $uid=$uid_of_user;
    }
}


# --listfiles and --uid or existing user (--user user)
if ($listfiles==1 and $uid!=0 ){
    my $out_file=$list_files_path."/".$login."-dir-list.txt";
    my $out_file_share=$list_files_path."/".$login."-dir-list-share.txt";
    my $out_file_summary=$list_files_path."/".
                         $login."-dir-list-summary.txt";
    my $out_file_tmp=$list_files_path."/".
                         $login."-dir-list-tmp.txt";
    open(SUMMARY, ">$out_file_summary");

    ########## searching $HOME of a user ##########
    # fetching $HOME
    my ($search_dir) = &fetchdata_from_account($login);
    print SUMMARY "##### Ordner im persoenlichen Ordner: #####\n";
    my $search_command="find $search_dir -maxdepth 1 ".
                       "-type d -user $login > $out_file";
    print "Looking for files of user $login with uid $uid:\n",
          "   $search_command\n";
    system($search_command);

    # Performance: 
    #   A) im home eines users(20 GB): ca. 30s
    #      Dateigroesse 6,7 MB, 72.000 Zeilen (1.800 Schreibmaschinenseiten)
    #   B) in /home user mit 20GB: ca: 
    #      Dateigroesse xx MB, x.000 Zeilen ( Schreibmaschinenseiten)
    # langsam
    #    find( \&files_of_uid,  @dirs);
    #    exit;

    # processing out_file
    my $count=-1;
    open(OUT, "<$out_file");
    while(<OUT>){
        my $dir=$_;
        chomp($dir);
        # ignore home
        if ($dir eq $search_dir){
            next;
        }
        # ignore dotfiles (--dotfiles, --nodotfiles) ?????
        if ($dir=~/$search_dir\/\./) {
            #print "Skipping dotfile $dir\n";
            next;
        }
        my $count_files=`find '$dir' -type f | wc -l`;
        my $count_dirs=`find '$dir' -type d | wc -l`;
        chomp($count_files);
        chomp($count_dirs);
        $count_dirs=$count_dirs-1; # ignore ..
        print SUMMARY "   $dir  --->  $count_dirs Ordner ",
                      "/ $count_files Dateien \n";
    }
    close(OUT);


    ########## searching /home/share ##########
    my $search_dir_share = "/home/share";
    print SUMMARY "##### Ordner in den Tausch-Ordnern: #####\n";
    #my $search_command_share="find $search_dir_share -maxdepth 2 ".
    #                   "-type d -user $login > $out_file_share";
    #print "Executing:\n   $search_command_share\n";
    #system($search_command_share);
    print "Looking in $search_dir_share/teachers for dirs:\n";
    system("find ${search_dir_share}/teachers -maxdepth 1 -type d -user $login > $out_file_share");

    print "Looking in $search_dir_share/classes for dirs:\n";
    system("find ${search_dir_share}/classes -maxdepth 2 -type d -user $login >> $out_file_share");

    print "Looking in $search_dir_share/subclasses for dirs:\n";
    system("find ${search_dir_share}/subclasses -maxdepth 2 -type d -user $login >> $out_file_share");

    print "Looking in $search_dir_share/projects for dirs:\n";
    system("find ${search_dir_share}/projects -maxdepth 2 -type d -user $login >> $out_file_share");

    print "Looking in $search_dir_share/exams for dirs:\n";
    system("find ${search_dir_share}/exams -maxdepth 2 -type d -user $login >> $out_file_share");

    print "Looking in $search_dir_share/school for dirs:\n";
    system("find ${search_dir_share}/school -maxdepth 1 -type d -user $login >> $out_file_share");

   # ????? -ignore_readdir_race einfuegen

    my $prune_string="";
    my %prune_hash=();

    my $count_share=-1;
    open(OUT, "<$out_file_share");
    while(<OUT>){
        my $dir=$_;
        chomp($dir);
        my $count_files=`find '$dir' -type f | wc -l`;
        my $count_dirs=`find '$dir' -type d | wc -l`;
        chomp($count_files);
        chomp($count_dirs);
        $count_dirs=$count_dirs-1; # ignore ..
        print SUMMARY "   $dir  --->  $count_dirs Ordner ",
                      "/ $count_files Dateien \n";
        # save dir and prune it in next find
        $prune_string=$prune_string."-path \"$dir\" -prune -o ";
	$prune_hash{$dir}="seen";
    }
    close(OUT);

# find /home/share/teachers/ -path /home/share/teachersopenoffice -prune -type f -user bz -o -print

    print SUMMARY "##### Sonstige Dateien in den Tausch-Ordnern: #####\n";

    #my $search_command_share_files="find $search_dir_share $prune_string ".
    #                   "-type f -user $login -o -print >> $out_file_summary";
    my $search_command_share_files="find $search_dir_share  $prune_string ".
                       "-type f -user $login >> $out_file_tmp";
    print "Looking in $search_dir_share for files:\n",
          "   $search_command_share_files\n";
    system($search_command_share_files);

    # remove pruned dirs from results 
    open(TMP, "<$out_file_tmp");
    while(<TMP>){
        my $line = $_;
        chomp($line);
        if (not exists $prune_hash{$line}){
            print SUMMARY "  $line\n";
        } else {
            # ignored
        }
    }
    close(TMP);

    # tauschdirs:
    # A) dirs suchen mit owner ...
    #    B) darin Anzahl Dateien und Ordner
    # C) alle Dateien suchen, Ordner von A) auslassen

    close(SUMMARY);
    print "--> Summary written to $out_file_summary\n";
    exit;
}



# ===========================================================================
# Subs
# ===========================================================================

sub files_of_user {
    my ($login) = @_;
    # find /home -user bz > bz-files-in-home.log
}

# langsam
sub files_of_uid {
    my ($f_dev, $f_ino, $f_mode, $f_nlink, $f_uid, $f_gid) = lstat($_);
    if ($uid==$f_uid){
        print "$uid $f_uid $File::Find::name\n";
        # do something with $File::Find::name

    }
}

sub get_horde_password {
    my $password="";
    my $conf="/etc/horde/horde3/conf.php";
    if (-e $conf){
        open (HORDECONF,$conf);
        while(<HORDECONF>){
            if (m/password/){
		my $line=$_;
                chomp($line);
                my ($trash,$string)=split(/=/,$line);
                $string=~m/ '([A-Za-z0-9_]+)';/;
                $password=$1;
            }
        }
        close HORDECONF;
    } else {
        print "\nERROR: Retrieving horde password failed:\n";
        print "    $conf nonexisting\n\n";
        exit;
    }
    return $password;
}
