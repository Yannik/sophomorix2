#!/usr/bin/perl -w
# Dieses Script (sophomorix-kill) wurde von Rüdiger Beck erstellt
# Es ist freie Software
# Bei Fehlern wenden Sie sich bitte an mich.
# jeffbeck@web.de  oder  jeffbeck@gmx.de

# Bibliotheken
use strict;
use Quota;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixBase;
use Sophomorix::SophomorixFiles;
#use Schedule::at;

# ===========================================================================
# Loading the db-Module, list of functions
# ===========================================================================
# list of functions to load if db is 'files'
use if ${DevelConf::db_backend} eq 'files' , 
    'Sophomorix::SophomorixFiles' => qw(show_modulename
                                        remove_user_db_entry
                                       );

# list of functions to load if db is 'ldap'
use if ${DevelConf::db_backend} eq 'ldap' ,
    'Sophomorix::SophomorixLDAP' => qw(show_modulename);;



# ===========================================================================
# Loading the sys-db-Module, list of functions
# ===========================================================================
# list of functions to load if db is 'files'
use if ${DevelConf::sys_db} eq 'files' , 
    'Sophomorix::SophomorixSYSFiles' => qw(show_sys_modulename
                                           delete_user_from_sys
                                          );
my $zeit=&zeit_stempel;
my $user_nummer=0;

my $identifier_to_kill="";
my $login_name_to_kill="";
my $home_verzeichnis_to_kill="";
my $linux_gruppe_to_kill="";
my $linie_to_kill="";
#my %protokoll_hash=();

my $k="";
my $v="";

# ===========================================================================
# Optionen verarbeiten
# ===========================================================================

# Variablen für Optionen
$DevelConf::testen=0;
$Conf::log_level=1;
my $help=0;
my $info=0;
my $loginname="";

# Parsen der Optionen
my $testopt=GetOptions(
           "test|t" => \$DevelConf::testen,
           "login|loginname|user|u|l=s" => \$loginname,
           "verbose|v+" => \$Conf::log_level,
           "info|i" => \$info,
           "help|h" => \$help
          );

# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);


# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung




   print('
sophomorix-kill removes users from the sophomorix database and deletes their data for good.

Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i  / --info
  -l  loginname /   --loginame loginname 
  -t  / --test

Please see the sophomorix-kill(8) man pages for full documentation
');
   print "\n";
   exit;
}


# --info
if ($info==1) {
   # Ausgabe der loeschbaren user

   print "\nFolgende User können endgültig gelöscht werden:\n\n";
   print "Loginname   AdminClass   Identifier\n";
   &linie;
   open(KILL,"${DevelConf::ergebnis_pfad}/sophomorix.kill") || die "Fehler: $!";
     while(<KILL>){
       chomp();
       ($identifier_to_kill, $login_name_to_kill)=split(/::/);
       # Klasse ermitteln
       ($linux_gruppe_to_kill)=&get_group_list($login_name_to_kill);
       printf "%-11s %-12s %-40s\n",
              "$login_name_to_kill","$linux_gruppe_to_kill","$identifier_to_kill";
     }
   close(KILL);
   print "\n";
   exit;
}

# --loginname
if ($loginname ne "") {
  #
  print "Loginname $loginname angegeben.\n";
}

# show the Database Modules that are loaded
&show_modulename();
&show_sys_modulename();

# ===========================================================================
# Abbruch, wenn sophomorix.kill fehlt oder leer
# ===========================================================================
if (not (-s "${DevelConf::ergebnis_pfad}/sophomorix.kill")) {
  print "\n  Die Datei\n\n";
  print "    ${DevelConf::ergebnis_pfad}/sophomorix.kill\n\n";
  print "  ist leer oder wurde nicht gefunden.\n\n";
  print "  Es sind keine User zu löschen\n\n";
  print "   sophomorix-kill beendet sich deshalb!\n\n";
  exit; 
}

# sophomorix database sichern
&backup_user_database($zeit, "before.kill");
# sophomorix.kill mitloggen
&backup_amk_file($zeit,"kill","before");

# ===========================================================================
# Protokolldatei lesen
# ===========================================================================
#%protokoll_hash=&protokoll_linien();
#%protokoll_hash=&get_protokoll_lines();


# ===========================================================================
# Datei mit den Schülern, die nicht gelöscht wurden
# ===========================================================================
open(YETTOKILL,">${DevelConf::ergebnis_pfad}/sophomorix.kill.neu") || die "Fehler: $!";


# ===========================================================================
# Datei mit den zu löschenden Schülern
# ===========================================================================
&titel("Löschvorgang beginnt ...");
print "${DevelConf::ergebnis_pfad}/sophomorix.kill";
open(KILL,"${DevelConf::ergebnis_pfad}/sophomorix.kill") || die "Fehler: $!";

while(<KILL>){
     $user_nummer++;
     chomp();
     ($identifier_to_kill, $login_name_to_kill)=split(/::/);
     # Klasse ermitteln
     ($linux_gruppe_to_kill)=&get_group_list($login_name_to_kill);
     # Home-Verzeichnis ermitteln
     ($a,$a,$a,$a,$a,$a,$a,$home_verzeichnis_to_kill,$a)=
      getpwnam($login_name_to_kill);

     # Abbruch, wenn nicht der richtige loginname entfernt wird
     if ($loginname ne "") {
       if ($login_name_to_kill ne $loginname) {
          print "\n$login_name_to_kill wird NICHT gelöscht\n";
          # Merken, dass user noch nicht entfernt wird
          print YETTOKILL "$_\n";
          next;
       }
     }

     #####################################
     # Ermittelte Daten ausgeben
     #####################################
     if($Conf::log_level>=1){
        print("\nEntferne User $user_nummer aus dem System:\n");
        print("Identifier:          $identifier_to_kill\n");
        print("Login-Name:          $login_name_to_kill\n");
        print("Home-Verzeichnis:    $home_verzeichnis_to_kill\n");
#        print("public_html:         $www_to_kill\n");
#        print("public_html-link:    $www_link_to_kill\n");
#        print("Protokolllinie:      $linie_to_kill\n");
        print("Klasse:              $linux_gruppe_to_kill\n\n");
      } 

      #####################################
      # Jetzt wird gelöscht
      #####################################   
      &delete_user_from_sys($login_name_to_kill);
      
      #####################################
      # Zeile aus user_db entfernen
      #####################################
 
     if ($DevelConf::testen==0) {
         &remove_user_db_entry($login_name_to_kill);
      } else {
        print "Nur Test:        Removing $login_name_to_kill from the",
              " sophomorix database.\n"
      }
     

      ############################################
      # Zusätzlich zu tun
      ############################################
      if ($linux_gruppe_to_kill eq "lehrer") {
          # Es ist ein Lehrer
          &webmin_eintrag_loeschen($login_name_to_kill);
       } else {
          # Es ist ein Schüler
          # Klassenverzeichnis in denen die Homes sind löschen, falls leer
          &do_falls_nicht_testen(
#             "rmdir --ignore-fail-on-non-empty /home/schueler/$linux_gruppe_to_kill",
             "rmdir --ignore-fail-on-non-empty ${DevelConf::homedir_pupil}/$linux_gruppe_to_kill",
          # Klassentauschverzeichnis löschen, falls leer 
          # (Ist normalerweise nicht Leer)
#          "rmdir --ignore-fail-on-non-empty /home/tausch/klassen/$linux_gruppe_to_kill"
          "rmdir --ignore-fail-on-non-empty ${DevelConf::share_classes}/$linux_gruppe_to_kill"
          );
       }


     
      # Sonst noch löschen:

      # find über die Tauschverzeichnisse, löschen (evt. noch aufheben)

      # Wenn letzter Schüler einer Klasse gelöscht wird:
      # Die Gruppe Klasse löschen (kein Nachteil, wenn die Gruppe erhalten bleibt)

      # Evtl. gefährlich:
      # Klassentauschverzeichnis löschen, wenn letzter Schüler gelöscht???

      # Logonscript für Klasse entfernen (nicht so wichtig)
      # Wenns die Klasse wiedergibt, wirds überbügelt
      # Wenns die Klasse nicht mehr gibt, liegt halt a bissle Müll herum

   }
close(KILL);
close(YETTOKILL);



# ===========================================================================
# Datei-Zustand (NACHHER) mitloggen 
# ===========================================================================
&titel("Datei-Zustand (NACHHER) mitloggen ...");

# ===========================================================================
# Verarbeitete Datei mit Zeitstempel versehen
# ===========================================================================
#&do_falls_nicht_testen(
#   "mv ${DevelConf::ergebnis_pfad}/sophomorix.kill ${DevelConf::log_pfad}/${zeit}.sophomorix.kill",
#   # Nur für root lesbar machen
#   "chmod 600 ${DevelConf::log_pfad}/${zeit}.sophomorix.kill"
#);



# sophomorix database sichern
&backup_user_database($zeit, "after.kill");
# sophomorix.kill mitloggen
&backup_amk_file($zeit,"kill","after");

# ===========================================================================
# Falls nur getestet wird, darf die Datei nicht ersetzt werden
# ===========================================================================
if ($DevelConf::testen==0) {
   # Kein Test
   rename("${DevelConf::ergebnis_pfad}/sophomorix.kill.neu",
          "${DevelConf::ergebnis_pfad}/sophomorix.kill" );
 } else {
   # Test
   system("rm -f ${DevelConf::ergebnis_pfad}/sophomorix.kill.neu > /dev/null");
 }


print ("\nsophomorix-kill terminated regularly ...\n");






# ===========================================================================
# sub
# ===========================================================================
sub webmin_eintrag_loeschen {
   my ($user)=@_;
   my $wmsu="/etc/webmin/miniserv.users";
   my $webminacl="/etc/webmin/webmin.acl";
   my @miniserv_users=();
   my @webmin_acl=();
   if (-e $wmsu){

      # ======================================================================
      #  miniserv.users mitloggen
      # ======================================================================
      &do_falls_nicht_testen(
         "cp  $wmsu ${DevelConf::log_pfad}/${zeit}.miniserv.users-vor",
         "chmod 600 ${DevelConf::log_pfad}/${zeit}.miniserv.users-vor"
      );

      open (MINISERVUSERS, "<$wmsu") 
        ||   die "Kann $wmsu nicht öffnen\n";
        # Zeilen in einer Liste speichern
        while(<MINISERVUSERS>){ 
          if (/^$user/){ # wenn die user-Zeile gefunden
            # nix tun
          } else {
            # zur Liste hinzu
            push(@miniserv_users, $_);
          }
        }
      close(MINISERVUSERS);

      if ($DevelConf::testen==0) {
         open (MINISERVUSERS, ">$wmsu"); 
           foreach $a (@miniserv_users){
             print MINISERVUSERS "$a";
           }
         close(MINISERVUSERS);
      } else {
         print "Test: miniservusers löschen\n";
      }

      # ======================================================================
      #  miniserv.users mitloggen
      # ======================================================================
      &do_falls_nicht_testen(
         "cp  $wmsu ${DevelConf::log_pfad}/${zeit}.miniserv.users-nach",
         "chmod 600 ${DevelConf::log_pfad}/${zeit}.miniserv.users-nach"
      );

      # Webmin acl für den Lehrer erstellen
      &do_falls_nicht_testen(
         "rm /etc/webmin/$user.acl"
      );

      # ======================================================================
      #   webmin.acl mitloggen
      # ======================================================================
      &do_falls_nicht_testen(
        "cp $webminacl  ${DevelConf::log_pfad}/${zeit}.webmin.acl-vor",
        "chmod 600 ${DevelConf::log_pfad}/${zeit}.webmin.acl-vor"
      );

      open (WEBMINACL, "<$webminacl") 
        ||   die "Kann $webminacl nicht öffnen\n";
        # Zeilen in einer Liste speichern
        while(<WEBMINACL>){ 
          if (/^$user/){ # wenn die user-Zeile gefunden
            # nix tun
          } else {
            # zur Liste hinzu
            push(@webmin_acl ,$_);
          }
        }
      close(WEBMINACL);

      if ($DevelConf::testen==0) {
        open (WEBMINACL, ">$webminacl"); 
           foreach $a (@webmin_acl){
             print WEBMINACL "$a";
           }
        close(WEBMINACL);
      }

      # ======================================================================
      #   webmin.acl mitloggen
      # ======================================================================
      &do_falls_nicht_testen(
         "cp $webminacl  ${DevelConf::log_pfad}/${zeit}.webmin.acl-vor",
         "chmod 600 ${DevelConf::log_pfad}/${zeit}.webmin.acl-vor"
      );

      open (WEBMINACL, "<$webminacl") 
        ||   die "Kann $webminacl nicht öffnen\n";
        # Zeilen in einer Liste speichern
        while(<WEBMINACL>){ 
           if (/^$user/){ # wenn die user-Zeile gefunden
             # nix tun
           } else {
             # zur Liste hinzu
             push(@webmin_acl ,$_);
           }
        }
      close(WEBMINACL);

      if ($DevelConf::testen==0) {
         open (WEBMINACL, ">$webminacl"); 
            foreach $a (@webmin_acl){
               print WEBMINACL "$a";
            }
         close(WEBMINACL);
      }

      # ======================================================================
      #   webmin.acl mitloggen
      # ======================================================================
      &do_falls_nicht_testen(
         "cp $webminacl  ${DevelConf::log_pfad}/${zeit}.webmin.acl-nach",
         "chmod 600 ${DevelConf::log_pfad}/${zeit}.webmin.acl-nach"
      );

      &do_falls_nicht_testen(
         "cp $webminacl  ${DevelConf::log_pfad}/${zeit}.webmin.acl-nach",
         "chmod 600 ${DevelConf::log_pfad}/${zeit}.webmin.acl-nach",
         "rm /etc/webmin/acl/$user.acl"
      );  
      # Angeben, welche Befehle der Lehrer in custom ausführen darf
      # Besser: Lehrer darf alle Befehle in der Rubrik Lehrer ausführen
      &do_falls_nicht_testen(
        "rm /etc/webmin/custom/$user.acl"
      );
   }
}
