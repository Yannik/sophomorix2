#!/usr/bin/perl -w
# Dieses Script (sophomorix-kill) wurde von Rüdiger Beck erstellt
# Es ist freie Software
# Bei Fehlern wenden Sie sich bitte an mich.
# jeffbeck@web.de  oder  jeffbeck@gmx.de

# Bibliotheken
use strict;
use Quota;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
use Sophomorix::SophomorixBase;
use Sophomorix::SophomorixFiles;
#use Schedule::at;

# Einlesen der Konfigurationsdatei für Entwickler
#{ package DevelConf ; do "/etc/sophomorix/devel/user/sophomorix-devel.conf"}

# jeffbecks Bibliothek und
# Einlesen der Konfigurationsdatei
#require "${DevelConf::library_pfad}/sophomorix-lib";



# ===========================================================================
# Loading the db-Module, list of functions
# ===========================================================================
# list of functions to load if db is 'files'
use if ${DevelConf::db_backend} eq 'files' , 
    'Sophomorix::SophomorixFiles' => qw(show_modulename
                                       );

# list of functions to load if db is 'ldap'
use if ${DevelConf::db_backend} eq 'ldap' ,
    'Sophomorix::SophomorixLDAP' => qw(show_modulename);;



# ===========================================================================
# Loading the sys-db-Module, list of functions
# ===========================================================================
# list of functions to load if db is 'files'
use if ${DevelConf::sys_db} eq 'files' , 
    'Sophomorix::SophomorixSYSFiles' => qw(show_sys_modulename
                                           delete_user_from_sys
                                          );






# Nur als Dummy(Warnings verhindern)
if($DevelConf::library_pfad){};

my $zeit=&zeit_stempel;
my $user_nummer=0;

my $identifier_to_kill="";
my $login_name_to_kill="";
my $home_verzeichnis_to_kill="";
my $linux_gruppe_to_kill="";
my $linie_to_kill="";
my %protokoll_hash=();

my $k="";
my $v="";

################################################################################
# User Löschen aus schueler.?????weg
################################################################################



# ===========================================================================
# Optionen verarbeiten
# ==========================================================================

# Variablen für Optionen
$DevelConf::testen=0;
$Conf::log_level=1;
my $help=0;
my $info=0;
my $loginname="";

# Parsen der Optionen
my $testopt=GetOptions(
           "test|t" => \$DevelConf::testen,
           "login|loginname|user|u|l=s" => \$loginname,
           "verbose|v+" => \$Conf::log_level,
           "info|i" => \$info,
           "help|h" => \$help
          );

# Prüfen, ob Optionen erkannt wurden, sonst Abbruch
&check_options($testopt);


# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlsbeschreibung
   print "$scriptname entfernt Schüler aus der Datei \n";
   print "   ${DevelConf::ergebnis_pfad}/user.hinzu \n";
   print "aus dem System\n\n";
   # gemeinsamer Hilfetext aller Scripten

   # optionen
   print "Optionen:\n\n";

   print "  --login user, --loginname user, --user user, -u user, -l user\n";
   print "     Es wird nur die Schülerin/der Schüler gelöscht, \n";
   print "     die/der den Benutzernamen user hat.\n\n";

   &help_text_all;
   
   print "Testen:\n\n";
   # testen
   print "  -t, --test\n";
   print "     Lehrer und Schüler werden nicht wirklich entfernt oder deakiviert. \n";
   print "     Ansonsten läuft $scriptname möglichst normal.\n\n";
   exit;
}


# --info
if ($info==1) {
   # Ausgabe der Löschbaren user

   print "\nFolgende User können endgültig gelöscht werden:\n\n";
   print "Loginname   Identifier\n";
   &linie;
   open(KILL,"${DevelConf::ergebnis_pfad}/sophomorix.kill") || die "Fehler: $!";
     while(<KILL>){
       chomp();
       ($identifier_to_kill, $login_name_to_kill)=split(/::/);
       # Klasse ermitteln
#       ($linux_gruppe_to_kill,$a,$a,$a,$a)=split(/;/,$linie_to_kill);
       printf "%-11s %-40s\n",
              "$login_name_to_kill","$identifier_to_kill";
     }
   close(KILL);
   print "\n";
   exit;
}

# --loginname
if ($loginname ne "") {
  #
  print "Loginname $loginname angegeben.\n";
}

# show the Database Modules that are loaded
&show_modulename();
&show_sys_modulename();

# ===========================================================================
# Abbruch, wenn sophomorix.kill fehlt oder leer
# ===========================================================================
if (not (-s "${DevelConf::ergebnis_pfad}/sophomorix.kill")) {
  print "\n  Die Datei\n\n";
  print "    ${DevelConf::ergebnis_pfad}/sophomorix.kill\n\n";
  print "  ist leer oder wurde nicht gefunden.\n\n";
  print "  Es sind keine User zu löschen\n\n";
  print "   sophomorix-kill beendet sich deshalb!\n\n";
  exit; 
}



# ===========================================================================
# Datei-Zustand (VORHER) mitloggen (user.protokoll)
# ===========================================================================
&titel("Datei-Zustand (VORHER) mitloggen ...");



&do_falls_nicht_testen(
     "cp ${DevelConf::protokoll_pfad}/user.protokoll ${DevelConf::log_pfad}/${zeit}.user.protokoll-vor",
     "chmod 600 ${DevelConf::log_pfad}/${zeit}.user.protokoll-vor"
);



# ===========================================================================
# Protokolldatei lesen
# ===========================================================================
#%protokoll_hash=&protokoll_linien();
%protokoll_hash=&get_protokoll_lines();


# ===========================================================================
# Datei mit den Schülern, die nicht gelöscht wurden
# ===========================================================================
open(YETTOKILL,">${DevelConf::ergebnis_pfad}/sophomorix.kill.neu") || die "Fehler: $!";


# ===========================================================================
# Datei mit den zu löschenden Schülern
# ===========================================================================
&titel("Löschvorgang beginnt ...");
print "${DevelConf::ergebnis_pfad}/sophomorix.kill";
open(KILL,"${DevelConf::ergebnis_pfad}/sophomorix.kill") || die "Fehler: $!";

while(<KILL>){
     $user_nummer++;
     chomp();
     ($identifier_to_kill, $login_name_to_kill)=split(/::/);
     # Klasse ermitteln
     #($linux_gruppe_to_kill,$a,$a,$a,$a)=split(/;/,$linie_to_kill);
     # Home-Verzeichnis ermitteln
     ($a,$a,$a,$a,$a,$a,$a,$home_verzeichnis_to_kill,$a)=
      getpwnam($login_name_to_kill);

     # Abbruch, wenn nicht der richtige loginname entfernt wird
     if ($loginname ne "") {
       if ($login_name_to_kill ne $loginname) {
          print "\n$login_name_to_kill wird NICHT gelöscht\n";
          # Merken, dass user noch nicht entfernt wird
          print YETTOKILL "$_\n";
          next;
       }
     }

     #####################################
     # Ermittelte Daten ausgeben
     #####################################
     if($Conf::log_level>=1){
        print("\nEntferne User $user_nummer aus dem System:\n");
        print("Identifier:          $identifier_to_kill\n");
        print("Login-Name:          $login_name_to_kill\n");
        print("Home-Verzeichnis:    $home_verzeichnis_to_kill\n");
#        print("public_html:         $www_to_kill\n");
#        print("public_html-link:    $www_link_to_kill\n");
#        print("Protokolllinie:      $linie_to_kill\n");
        print("Klasse:              $linux_gruppe_to_kill\n\n");
      } 

      #####################################
      # Jetzt wird gelöscht
      #####################################   
      &delete_user_from_sys($login_name_to_kill);
      
      #####################################
      # Zeile aus user.protokoll entfernen
      #####################################
 
     if ($DevelConf::testen==0) {
         # Linie aus dem Hash löschen
         delete($protokoll_hash{$login_name_to_kill});
      
         # verbleibende Daten des Hash in Datei zurückschreiben
         open(PROTOKOLL,">$DevelConf::protokoll_datei");
            foreach (keys %protokoll_hash){
               print PROTOKOLL "$protokoll_hash{$_}";
            }
            # Datei Schließen, damit Schreiben erzwingen (Falls Programmabsturz)
         close(PROTOKOLL);
      } else {
        print "Nur Test:        $DevelConf::protokoll_datei modifizieren\n"
      }
     

      ############################################
      # Zusätzlich zu tun
      ############################################
      if ($linux_gruppe_to_kill eq "lehrer") {
          # Es ist ein Lehrer
          &webmin_eintrag_loeschen($login_name_to_kill);
       } else {
          # Es ist ein Schüler
          # Klassenverzeichnis in denen die Homes sind löschen, falls leer
          &do_falls_nicht_testen(
             "rmdir --ignore-fail-on-non-empty /home/schueler/$linux_gruppe_to_kill",
          # Klassentauschverzeichnis löschen, falls leer (Ist normalerweise nicht Leer)
             "rmdir --ignore-fail-on-non-empty /home/tausch/klassen/$linux_gruppe_to_kill"
          );
       }


     
      # Sonst noch löschen:

      # find über die Tauschverzeichnisse, löschen (evt. noch aufheben)

      # Wenn letzter Schüler einer Klasse gelöscht wird:
      # Die Gruppe Klasse löschen (kein Nachteil, wenn die Gruppe erhalten bleibt)

      # Evtl. gefährlich:
      # Klassentauschverzeichnis löschen, wenn letzter Schüler gelöscht???

      # Logonscript für Klasse entfernen (nicht so wichtig)
      # Wenns die Klasse wiedergibt, wirds überbügelt
      # Wenns die Klasse nicht mehr gibt, liegt halt a bissle Müll herum

   }
close(KILL);
close(YETTOKILL);



# ===========================================================================
# Datei-Zustand (NACHHER) mitloggen 
# ===========================================================================
&titel("Datei-Zustand (NACHHER) mitloggen ...");

# ===========================================================================
# Verarbeitete Datei mit Zeitstempel versehen
# ===========================================================================
&do_falls_nicht_testen(
   "mv ${DevelConf::ergebnis_pfad}/sophomorix.kill ${DevelConf::log_pfad}/${zeit}.sophomorix.kill",
   # Nur für root lesbar machen
   "chmod 600 ${DevelConf::log_pfad}/${zeit}.sophomorix.kill"
);



# ===========================================================================
# user.protokoll mitloggen
# ===========================================================================
&do_falls_nicht_testen(
   "cp ${DevelConf::protokoll_pfad}/user.protokoll ${DevelConf::log_pfad}/${zeit}.user.protokoll-nach",
   "chmod 600 ${DevelConf::log_pfad}/${zeit}.user.protokoll-nach"
);

# ===========================================================================
# Falls nur getestet wird, darf die Datei nicht ersetzt werden
# ===========================================================================
if ($DevelConf::testen==0) {
   # Kein Test
   rename("${DevelConf::ergebnis_pfad}/sophomorix.kill.neu",
          "${DevelConf::ergebnis_pfad}/sophomorix.kill" );
 } else {
   # Test
   system("rm -f ${DevelConf::ergebnis_pfad}/sophomorix.kill.neu > /dev/null");
 }


print ("\nsophomorix-kill terminated regularly ...\n");






# ===========================================================================
# sub
# ===========================================================================
sub get_protokoll_lines {
    my %data=();
    my $login="";
    open(READIN, "<${DevelConf::protokoll_pfad}/user.protokoll");
    while (<READIN>){
        ($a,$a,$login)=split(/;/);
        $data{$login}=$_;
    }
    close(READIN);

while (($k,$v) = each %data){
    print $k ,"    ",$v;
}
    return %data,
}




sub webmin_eintrag_loeschen {
   my ($user)=@_;
   my $webmin_miniserv_users="/etc/webmin/miniserv.users";
   my $webminacl="/etc/webmin/webmin.acl";
   my @miniserv_users=();
   my @webmin_acl=();

   # ===========================================================================
   #  miniserv.users mitloggen
   # ===========================================================================
   &do_falls_nicht_testen(
      "cp  $webmin_miniserv_users ${DevelConf::log_pfad}/${zeit}.miniserv.users-vor",
      "chmod 600 ${DevelConf::log_pfad}/${zeit}.miniserv.users-vor"
   );

   open (MINISERVUSERS, "<$webmin_miniserv_users") 
      ||   die "Kann $webmin_miniserv_users nicht öffnen\n";
      # Zeilen in einer Liste speichern
      while(<MINISERVUSERS>){ 
         if (/^$user/){ # wenn die user-Zeile gefunden
            # nix tun
         } else {
            # zur Liste hinzu
            push(@miniserv_users, $_);
          }
       }
   close(MINISERVUSERS);

   if ($DevelConf::testen==0) {
      open (MINISERVUSERS, ">$webmin_miniserv_users"); 
        foreach $a (@miniserv_users){
            print MINISERVUSERS "$a";
          }
      close(MINISERVUSERS);
    } else {
      print "Test: miniservusers löschen\n";
    }


   # ===========================================================================
   #  miniserv.users mitloggen
   # ===========================================================================
   &do_falls_nicht_testen(
      "cp  $webmin_miniserv_users ${DevelConf::log_pfad}/${zeit}.miniserv.users-nach",
      "chmod 600 ${DevelConf::log_pfad}/${zeit}.miniserv.users-nach"
   );

   # Webmin acl für den Lehrer erstellen
   &do_falls_nicht_testen(
      "rm /etc/webmin/$user.acl"
   );

   # ===========================================================================
   #   webmin.acl mitloggen
   # ===========================================================================
   &do_falls_nicht_testen(
      "cp $webminacl  ${DevelConf::log_pfad}/${zeit}.webmin.acl-vor",
      "chmod 600 ${DevelConf::log_pfad}/${zeit}.webmin.acl-vor"
   );

   open (WEBMINACL, "<$webminacl") 
      ||   die "Kann $webminacl nicht öffnen\n";
      # Zeilen in einer Liste speichern
      while(<WEBMINACL>){ 
         if (/^$user/){ # wenn die user-Zeile gefunden
            # nix tun
         } else {
            # zur Liste hinzu
            push(@webmin_acl ,$_);
          }
       }
   close(WEBMINACL);

   if ($DevelConf::testen==0) {
      open (WEBMINACL, ">$webminacl"); 
          foreach $a (@webmin_acl){
            print WEBMINACL "$a";
          }
      close(WEBMINACL);
   }

   # ===========================================================================
   #   webmin.acl mitloggen
   # ===========================================================================
      &do_falls_nicht_testen(
      "cp $webminacl  ${DevelConf::log_pfad}/${zeit}.webmin.acl-vor",
      "chmod 600 ${DevelConf::log_pfad}/${zeit}.webmin.acl-vor"
   );

   open (WEBMINACL, "<$webminacl") 
      ||   die "Kann $webminacl nicht öffnen\n";
      # Zeilen in einer Liste speichern
      while(<WEBMINACL>){ 
         if (/^$user/){ # wenn die user-Zeile gefunden
            # nix tun
         } else {
            # zur Liste hinzu
            push(@webmin_acl ,$_);
          }
       }
   close(WEBMINACL);

   if ($DevelConf::testen==0) {
      open (WEBMINACL, ">$webminacl"); 
          foreach $a (@webmin_acl){
            print WEBMINACL "$a";
          }
      close(WEBMINACL);
   }

   # ===========================================================================
   #   webmin.acl mitloggen
   # ===========================================================================
   &do_falls_nicht_testen(
      "cp $webminacl  ${DevelConf::log_pfad}/${zeit}.webmin.acl-nach",
      "chmod 600 ${DevelConf::log_pfad}/${zeit}.webmin.acl-nach"
   );

   &do_falls_nicht_testen(
      "cp $webminacl  ${DevelConf::log_pfad}/${zeit}.webmin.acl-nach",
      "chmod 600 ${DevelConf::log_pfad}/${zeit}.webmin.acl-nach",
      "rm /etc/webmin/acl/$user.acl"
   );  
   # Angeben, welche Befehle der Lehrer in custom ausführen darf
   # Besser: Lehrer darf alle Befehle in der Rubrik Lehrer ausführen
   &do_falls_nicht_testen(
      "rm /etc/webmin/custom/$user.acl"
   );
 }
