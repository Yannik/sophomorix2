#!/usr/bin/perl -w
# $Id$
# This script (sophomorix-workstation) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@gmx.de


# ??? valid pxe options ???
# ??? netmask check ??? 
# some check depend on other: 
#   double ip can only be checked if ip is correct

## --print
# add this to doku and man page:
# 1. Die Ergebnisdatei entsteht in /etc/linuxmuster/

# 2. Formatieren Sie /etc/linuxmuster/workstations mit Kommentaren:
#      # Das wird eine Überschrift     (1 #-Zeichen)
#      ## Das bleibt unberücksichtigt  (2 #-Zeichen) 

# Todo für ML 5.0
# oneside/twoside konfigurierbar
# Unter 1 aufgeführte Variablen selber ermitteln
# Text in lang-Datei auslagern



# ===========================================================================
# Bibliotheken
# ===========================================================================
use strict;
use Getopt::Long;
Getopt::Long::Configure ("bundling");
#use Schedule::at;
use String::Approx 'amatch';
use Sophomorix::SophomorixConfig;
use Sophomorix::SophomorixBase;
use Time::Local;
use Time::localtime;
use Term::ANSIColor qw(:constants); # farbiger Text RED, BLUE, ...
# nach jedem Printbefehl wieder auf Standardfarbe zurücksetzen
$Term::ANSIColor::AUTORESET = 1;
use IMAP::Admin;
use DBI;
use Net::LDAP;
use Net::MAC;
use Date::Calc qw(check_date);
use Sophomorix::SophomorixPgLdap qw(show_modulename
                                    db_connect
                                    db_disconnect
                                    check_connections
                                    search_user
                                    fetchdata_from_account
                                    forbidden_login_hash
                                    update_user_db_entry
                                    date_pg2perl
                                    user_deaktivieren
                                    user_reaktivieren     
                                    check_sophomorix_user
                                    set_sophomorix_passwd
                                    fetchstudents_from_adminclass
                                    db_connect
                                   );

my @arguments = @ARGV;


my $today=`date +%d.%m.%Y`;
chomp($today);

# ===========================================================================
# Optionen verarbeiten
# ==========================================================================
$Conf::log_level=1;
my $help=0;
my $info=0;
my $print=0;

# ??? develconf ???
my $workstation_conf="/etc/linuxmuster/workstations";

my %host_seen=();
my %mac_seen=();
my %ip_seen=();

my @adding_examaccount=();
my @killing_examaccount=();
my @adding_computer=();
my @killing_computer=();

my %pxe = qw( 0 ok
             22 ok
             ml ok
            );


# Parsen der Optionen
my $testopt=GetOptions(
       "verbose|v+" => \$Conf::log_level,
       "help|h" => \$help,
       "i|info" => \$info,
       "p|print" => \$print,
          );


# Prüfen, ob Optionen erkannt wurden
&check_options($testopt);
&check_connections();

# ===========================================================================
# --help
# ===========================================================================
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlbeschreibung
   print('
sophomorix-workstation adds the DomainComputer and Examaccount 
  from /etc/linuxmuster/workstation

Options
  -h   /  --help
  -i   /  --info
  -v   /  --verbose
  -vv  /  --verbose --verbose

Please see the sophomorix-workstation(8) man pages for full documentation
');
   print "\n";

   exit;
}


# ===========================================================================
# --print
# ===========================================================================
if ($print==1){
    if (not -e ${workstation_conf}){
        print "\n$workstation_conf does not exist\n\n";
        exit 1;
    }

    my $admins="";
    if (defined $Conf::admins_print){
        if ($Conf::admins_print ne ""){
	    $admins=$Conf::admins_print;
        }
    }

    my $out_base="/etc/linuxmuster/workstations_formatted";
    my $out_dir="/etc/linuxmuster";
    my $out_file="$out_base".".tex";
    my $out_file_dvi="$out_base".".dvi";
    my @line=();
    my $host=0; # conter for the hosts
    # draw a horizontal line in the table after this many lines of text
    my $hor_lines=5; 
    my $line_count=1;


    print "Writing to $out_file";
    open(TEX, ">$out_file");

    print TEX '\documentclass[a4paper, twoside]{article}',"\n",
          '\usepackage{longtable}',"\n",
          '\usepackage{ngerman}',"\n",
          '\usepackage{layout}',"\n",
          '\usepackage{fancyhdr}',"\n",
          '\usepackage{lastpage}',"\n",
          '\setlength{\oddsidemargin}{-5mm}',"\n",
          '\setlength{\evensidemargin}{-16.8mm}',"\n",
          '\setlength{\textwidth}{180mm}',"\n",
          '\setlength{\textheight}{255mm}',"\n",
          '\setlength{\topmargin}{-20mm}',"\n",
          '\pagestyle{fancy}',"\n",
          "\\lhead{$Conf::schul_name}","\n",
          "\\rhead{Seite \\thepage/\\pageref{LastPage}}","\n",
          "\\cfoot{$admins}","\n",
          '\pagestyle{fancy}',"\n",
          '\renewcommand{\baselinestretch}{1.2}',"\n\n",

          '\begin{document}',"\n\n",
          # show layout of page
          # '\layout',"\n\n",
          '\begin{longtable}{|r|c|c|c|c|c|} ',"\n",
          '   \caption*{\large \bfseries Rechner und ',
          '             Drucker ',
          "($Conf::schul_name)",
          '}\\\\ \\hline',"\n",
          '   \bfseries Nr. & \bfseries DNS-Name & \bfseries Raum & ',
          '      \bfseries HW-Klasse & \bfseries IP-Adresse & ',
          '      \bfseries MAC-Adresse \\\\ \hline \hline',"\n",
          '   \endhead',"\n",
          '      \hline \multicolumn{6}{r}{Fortsetzung auf ',
          '          der n\"{a}chsten Seite ...}',"\n",
          '   \endfoot',"\n",
          '      \hline ',"\n",
          '   \endlastfoot',"\n";

    open(IN, "<${workstation_conf}");
    while(<IN>){
        chomp();
        my $line=$_;
        if ($line eq "") {
	    next;
        } elsif(/^\#\#/){
	    print "Comment $line \n";
        } elsif (/^\#/){
	    print "Header $line \n";
            s/^\#//g;
            if ($line eq "") {
	        next;
            }
            $line=&latexize_string($line);
            print TEX "\\hline \\hline  ",
                 "\\multicolumn{6}{|l|}{\\rule{0mm}{4mm}\\bfseries $line}",
                 " \\\\ \\hline ","\n";
        } else {
            @line = split(/;/);
            $host++;
            print TEX "$host & $line[1] & $line[0] & ",
                      "$line[2] & $line[4] & \\texttt{$line[3]} \\\\ ";
            # Horizontal lines
            if ($line_count==$hor_lines){
                print TEX ' \hline',"\n";
                $line_count=0;
            } else {
                print TEX "\n";
            }
            $line_count++;
        }
    }
    close(IN);

    print TEX '\end{longtable}',"\n";
    print TEX "\\textbf{$host Rechner/Drucker sind im p\"{a}dagogischen ",
              "Netz ($Conf::schul_name).} \n \n";
    print TEX "Ausdruck: \\today .",
              "\n \n",
              "\\textbf{Die Netzwerkadministratoren:}",
              "\n",
              "$admins","\n";
    print TEX "\n",'\end{document}',"\n";
    close(TEX);

    # latex
    system("cd $out_dir; latex $out_file");
    system("cd $out_dir; latex $out_file");
    system("cd $out_dir; dvips $out_file_dvi");
    exit;
}







# ===========================================================================
# fetching data
# ===========================================================================
&titel("Asking the system for users ...");

my ($ref_domcomputers,$ref_rooms,$ref_examaccounts) = &get_sys_workstations();

# domcomputers room
my %domcomputers_system = %$ref_domcomputers;
my %rooms_system = %$ref_rooms;
my %examaccounts_system = %$ref_examaccounts; 









# ===========================================================================
# --info
# ===========================================================================
if ($info==1){
    # fetch and sort rooms
    my @rooms=();
    while (my ($room,$v) = each %rooms_system){
        push @rooms, $room;
    }
    @rooms = sort @rooms;

    foreach my $room (@rooms){
	print "$room\n";
        # fetch and sort examaccounts
        my @examaccounts=();
        while (my ($account,$roomentry) = each %examaccounts_system){
            #print $account , " ", $roomentry, "\n";
            if ($roomentry eq $room){
                push @examaccounts,$account;
            }
        }
        @examaccounts = sort @examaccounts;
        foreach my $account (@examaccounts){
            print "    $account\n";
        }
    }
}





# ===========================================================================
# checking data
# ===========================================================================
print "Checking $workstation_conf for syntax errors ...\n";
if (not -e ${workstation_conf}){
    print "\n$workstation_conf does not exist\n\n";
    exit 1;
}
open(WORKSTATION,"<${workstation_conf}");
while(<WORKSTATION>){
    &analyze_line($_);
}

close(WORKSTATION);

# syntax OK: -> 0
#return 0;
# systax ERROR -> 1

print "... checking for syntax errors done.\n";

print "\nExamaccounts that must be added:\n";
print "------------------------------------",
      "------------------------------------\n";
foreach my $ws (@adding_examaccount){
    print "ADD: $ws\n";
}

print "\nExamaccounts that must be killed:\n";
print "------------------------------------",
      "------------------------------------\n";
foreach my $ws (@killing_examaccount){
    print "KILL: $ws\n";
}


print "\nComputers that must be added:\n";
print "------------------------------------",
      "------------------------------------\n";
foreach my $ws (@adding_computer){
    print "ADD: $ws\n";
}

print "\nComputers that must be killed:\n";
print "------------------------------------",
      "------------------------------------\n";
foreach my $ws (@killing_computer){
    print "KILL: $ws\n";
}


exit 0;





# ===========================================================================
# subs
# ===========================================================================
sub analyze_line {
    my ($line) = @_;
    if (/^#/ or /^\s*$/){
        return 0;
    } else {
        print "$line";
        chomp($line);
        my ($room,
            $host,
            $hwk,
            $mac,
            $ip,
            $netmask,
            $part1,
            $part2,
            $part3,
            $part4,
            $pxe,
            $option)=split(/;/,$line);

        &check_room($room);
        &check_host($host);
        &check_hwk($hwk);
        &check_mac($mac);
        &check_ip($ip);
        &check_netmask($netmask);
#        print "   PART 1:  $part1\n";
#        print "   PART 2:  $part2\n";
#        print "   PART 3:  $part3\n";
#        print "   PART 4:  $part4\n";
        &check_pxe($pxe);
        if (not defined $option){
            $option="";
            # ??? warning ???
        }
        if($Conf::log_level>=2){
            print "   OPTION:  $option\n";
        }

        # workstation is correct

        # check examaccount
        if (not exists $examaccounts_system{$host}){
            # nonexisting --> add account
            &push_add_examaccount($line);
        } else {
            if ($examaccounts_system{$host} ne $room){
                # exists in wrong room ---> kill/add account
                &push_kill_examaccount($line);
                &push_add_examaccount($line);
            }
        } 

        # check computer account
        my $host_computer = $host."\$";
        if (not exists $domcomputers_system{$host_computer} ){
            # nonexisting --> add account
            &push_add_computer($line);
        }





    }
}



sub check_room {
    my ($string) = @_;
    if($Conf::log_level>=2){
        print "   ROOM:    $string\n";
    }
    if ( $string=~/[^A-Za-z0-9\-]/ ) {
        print "\nERROR: $string contains invalid characters\n\n";
        exit 1;
    } else {

    }
}



sub check_host {
    my ($string) = @_;
    if($Conf::log_level>=2){
        print "   HOST:    $string\n";
    }
    if ( $string=~/[^A-Za-z0-9\-]/ ) {
        print "\nERROR: $string contains invalid characters\n\n";
        exit 1;
    } else {
        # correct
        if (exists $host_seen{$string}){
            print "\nERROR: HOST $string is double!\n\n";
            exit 1;
        } else {
            $host_seen{$string}="seen";
        }
    }
}



sub check_hwk {
    # ist - erlaubt?
    my ($string) = @_;
    if($Conf::log_level>=2){
        print "   HWK:     $string\n";
    }
    if ( $string=~/[^A-Za-z0-9]/ ) {
        print "\nERROR: $string contains invalid characters\n\n";
        exit 1;
    } else {

    }
}



sub check_mac {
    my ($string) = @_;
    if($Conf::log_level>=2){
       print "   MAC:     $string\n";
    }
    my $mac = Net::MAC->new('mac' => $string , base => 16); 
    my $new_mac = $mac->convert(
          'base'      => 16,   # convert to base 16, if necessary
          'bit_group' => 8,    # 16 bit grouping
          'delimiter' => ':',  # dot-delimited
          'die'       => 1     # die if conversion fails
	);
    # should die when mac is wrong

    # correct
    if (exists $mac_seen{$string}){
        print "\nERROR: MAC $string is double!\n\n";
        exit 1;
    } else {
        $mac_seen{$string}="seen";
    }
    if($Conf::log_level>=2){
        print "      OLD: $mac\n";
        print "      NEW: $new_mac\n";
    }
}



sub check_ip {
    my ($string) = @_;
    if($Conf::log_level>=2){
        print "   IP:      $string";
    }
    # check for 3 .
    my $dots_in_string=$string=~tr/\.//;
    if($Conf::log_level>=2){
        print " ($dots_in_string dots)\n";
    }
    if ($dots_in_string!=3){
        print "\nERROR: ->$string<- does not contain 3 dots\n\n";
        exit 1;        
    }
    
    # check for correct octets    
    my @octets = split(/\./,$string);
    foreach my $octet (@octets){
        if($Conf::log_level>=2){
            print "      Octet:    $octet\n";
        }
        if ( int($octet) < 1 or int($octet) > 255) {
            print "\nERROR: ->$string<- is invalid Option in ip octet\n\n";
            exit 1;
        } else {

        }
    }

    # check for double ip
    if (exists $ip_seen{$string}){
        print "\nERROR: IP $string is double!\n\n";
        exit 1;
    } else {
        $ip_seen{$string}="seen";
    }
}



sub check_netmask {
    my ($string) = @_;
    if($Conf::log_level>=2){
        print "   NETMASK: $string";
    }
    # check for 3 .
    my $dots_in_string=$string=~tr/\.//;
    if($Conf::log_level>=2){
        print " ($dots_in_string dots)\n";
    }
    if ($dots_in_string!=3){
        print "\nERROR: ->$string<- does not contain 3 dots\n\n";
        exit 1;        
    }

    my @octets = split(/\./,$string);
    foreach my $octet (@octets){
        if($Conf::log_level>=2){
            print "      Octet:    $octet\n";
        }
        if ( int($octet) < 0 or int($octet) > 255) {
            print "\nERROR: ->$string<- is invalid Option in netmask\n\n";
            exit 1;
        } else {

        }
    }
}



sub check_pxe {
    # ist - erlaubt?
    my ($string) = @_;
    if($Conf::log_level>=2){
        print "   PXE:     $string\n";
    }
    if ( not exists $pxe{$string} ) {
        print "\nERROR: ->$string<- is invalid Option in pxe field\n\n";
        exit 1;
    } else {

    }
}



sub get_sys_workstations {
    my %domcomputers_system = ();
    my %rooms_system = ();
    my %examaccounts_system = ();

    my $dbh=&db_connect();

    # domcomputers

    # select the columns that i need
    my $sth= $dbh->prepare( "SELECT uid,gid,homedirectory 
                               FROM userdata 
                              WHERE gid='domcomputers'" );
    $sth->execute();

    my $array_ref = $sth->fetchall_arrayref();

    foreach my $row (@$array_ref){
        # split the array, to give better names
        # or use numbers and look in the SELECT statement
        my $account_type="",

        my ($domcomputer,
            $room,
            $home,
           ) = @$row;
        #print "\n";
        #print "Host:  $domcomputer\n";
        #print "Room:  $room\n";
        #print "Home:  $home\n";
        $domcomputers_system{$domcomputer}=$room;
    }

    # examaccounts

    # select the columns that i need
    my $sth2= $dbh->prepare( "SELECT uid,gid,homedirectory 
                               FROM userdata 
                              WHERE homedirectory LIKE '/home/workstations%'" );
    $sth2->execute();

    my $array_ref2 = $sth2->fetchall_arrayref();

    foreach my $row (@$array_ref2){
        # split the array, to give better names
        # or use numbers and look in the SELECT statement
        my $account_type="",

        my ($exam_account,
            $room,
            $home,
           ) = @$row;
        #print "\n";
        #print "EXAM:  $exam_account\n";
        #print "Room:  $room\n";
        #print "Home:  $home\n";
        $examaccounts_system{$exam_account}=$room;
        $rooms_system{$room}="seen";
    }



    # room sortieren



    &db_disconnect($dbh);
    # returns some Hashes, as a list
    # 1:  workstation - room
    # 2:  room - workstation
    return(\%domcomputers_system, 
           \%rooms_system, 
           \%examaccounts_system, 
          );
}



sub push_add_examaccount {
    my ($add) = @_;
    push @adding_examaccount, $add;
}



sub push_kill_examaccount {
    my ($kill) = @_;
    push @killing_examaccount, $kill;
}



sub push_add_computer {
    my ($add) = @_;
    push @adding_computer, $add;
}



sub push_kill_computer {
    my ($kill) = @_;
    push @killing_computer, $kill;
}

