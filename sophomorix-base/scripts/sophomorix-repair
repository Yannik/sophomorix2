#!/usr/bin/perl -w
# $Id$
# Dieses Script (sophomorix-repair) wurde von Rüdiger Beck erstellt
# Es ist freie Software
# Bei Fehlern wenden Sie sich bitte an mich.
# jeffbeck@web.de  oder  jeffbeck@gmx.de


# Bibliotheken
use strict;
use Getopt::Long;
use Sophomorix::SophomorixConfig;
use Sophomorix::SophomorixBase;
use Sophomorix::SophomorixAPI;
use Sophomorix::SophomorixPgLdap;
Getopt::Long::Configure ("bundling");
use DBI;
use Sophomorix::SophomorixPgLdap qw(show_modulename
                                    pg_get_adminclasses
                                   );
my @arguments = @ARGV;

my $user="";
my $klasse="";
my $gruppe="";

my $help=0;
my $info=0;
my $filename="";
my $dateirechte=0;
my $htaccess=0;
my $schueler=0;
my $lehrer=0;
my $login="";
my $command_number=0;
my $skiplock=0;
$Conf::log_level=1;

###############################################################################
# Beginn
###############################################################################
# Datei, die die zu reparierenden Verzeichnisse beinhaltet
my $repair_directories="$DevelConf::devel_pfad/repair.directories";


# Parsen der Optionen
my $testopt=GetOptions(
           "help|h" => \$help,
           "info|i" => \$info,
           "verbose|v+" => \$Conf::log_level,
           "permissions|p" => \$dateirechte,
           "htaccess" => \$htaccess,
           "command-number=n" => \$command_number,
           "user|u=s" => \$login,
           "skiplock" => \$skiplock,
           "file|f=s" => \$filename
          );

# Prüfen, ob Optionen erkannt wurden
&check_options($testopt);
&log_script_start(@arguments);


if ($dateirechte==0 
    and $htaccess==0
    and $info==0) {
   # Es muss eine Option angegeben werden, sonst hilfe
   $help=1;
}


# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlbeschreibung
   print "\n$scriptname repairs the permissions ",
         "of a sophomorix installation,\n",
         "reading the permissions from $repair_directories.\n\n";
   print('
Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i
  -f filename / --file filename

What to repair:
  -p  / --permissions
  --htaccess
  --acl (Todo)

Limit the repair to a command-number (show the numbers with -i):
  --command-number number

Limit the repair to some users:
  -u user / --user user (Todo)
  --students (Todo)
  --teachers (Todo)

Please see the sophomorix-repair(8) man pages for full documentation
');
   &log_script_exit("",1,1,0,@arguments);
}




# --file
if ($filename ne "") {
   if (-e $filename) {
      print "\nRepariere Verzeichnisse aus $filename\n";
      $repair_directories="$filename";
   } else {
      print "\n   ABBRUCH - Nichtexistierende Datei: $filename\n\n";
      &log_script_exit("Nonexisting file $filename",1,1,0,@arguments);
    }
}


# repair.directories einlesen
&titel("Reading permision data ...");
&get_alle_verzeichnis_rechte();


###############################################################################
# Gruppenlisten/Userlisten erstellen
###############################################################################

# Klassen
&titel("Creating list of every AdminClass ...");
#my @klassen=&get_adminclasses_school(); 
#my @klassen=&pg_get_adminclasses(); 
my @klassen=&fetchadminclasses_from_school(); 
&print_list("The list of every AdminClass:",@klassen);

# Subclasses
&titel("Creating list of every AdminClass with subclasses...");
#my @klassen_sub=&get_adminclasses_sub_school(); 
my @klassen_sub=&fetchsubclasses_from_school(); 
&print_list("The list of every AdminClass with subclasses:",@klassen_sub);

# Projects
&titel("Creating list of every Project ...");
#my @projects=&get_projects_school(); 
my @projects=&fetchprojects_from_school(); 
&print_list("The list of every Project:",@projects);

# Räume
&titel("Creating list of every room ...");
#my @raeume=&get_raeume_in_schule(); 
my @raeume=&fetchrooms_from_school(); 
&print_list("The list of every room:",@raeume);



# Userlisten

# schueler
&titel("Creating list of every pupil ...");
#my @schueler=&get_pupils_school();
my @schueler=&fetchstudents_from_school();
&print_list("The list of every pupil:",@schueler);



# lehrer
&titel("Creating list of every teacher ...");
#my @lehrer=&get_lehrer_in_schule();
my @lehrer=&fetchstudents_from_adminclass(${DevelConf::teacher});
&print_list("The list of every teacher:",@lehrer);

# workstations
&titel("Creating list of every workstation ...");
#my @workstations=&get_workstations_in_schule();
#my @workstations=&get_workstations_school();
my @workstations=&fetchworkstations_from_school();
&print_list("The list of every workstation:",@workstations);


# --permissions
if ($dateirechte==1 or $info==1) {
   &repair_directories();
   &log_script_exit("",1,1,0,@arguments);
}

# --htaccess
if ($htaccess==1){
   &repair_htaccess();
   &log_script_exit("",1,1,0,@arguments);
}


&log_script_end(@arguments);




###############################################################################
# Erzeugt für jede Zeile von repair.directories einen Befehl
###############################################################################
sub repair_htaccess {
    print "Repairing htaccess files of adminclasses:\n";
    foreach my $group (@klassen){
        my $access=&fetchhtaccess_from_group($group);
        &set_htaccess_for_group($group,$access);
    }
    print "Repairing htaccess files of projects:\n";
    foreach my $group (@projects){
        my $access=&fetchhtaccess_from_group($group);
        &set_htaccess_for_group($group,$access);
    }
    &log_script_exit("",1,1,0,@arguments);
    print "Repairing htaccess files of students:\n";
    foreach my $student (@schueler){
        my $access=&fetchhtaccess_from_user($student);
        &set_htaccess_for_user($student,$access);
    }
    print "Repairing htaccess files of teachers:\n";
    foreach my $teacher (@lehrer){
        my $access=&fetchhtaccess_from_user($teacher);
        &set_htaccess_for_user($teacher,$access);
    }
}


sub set_htaccess_for_user {
    my ($user,$access) = @_;
    if ($access eq "user-public-upload"){
        &user_public_upload($user);
    } elsif ($access eq "user-private-upload"){
        &user_private_upload($user);
    } elsif ($access eq "user-public-noupload"){
        &user_public_noupload($user);
    } elsif ($access eq "user-private-noupload"){
        &user_private_noupload($user);
    }
}

sub set_htaccess_for_group {
    my ($group,$access) = @_;
    if ($access eq "group-public-upload"){
        &group_public_upload($group);
    } elsif ($access eq "group-private-upload"){
        &group_private_upload($group);
    } elsif ($access eq "group-public-noupload"){
        &group_public_noupload($group);
    } elsif ($access eq "group-private-noupload"){
        &group_private_noupload($group);
    }
}


sub repair_directories {
   # Liste mit einem Element, dass die Schleifen EINMAL durchlaufen werden
   my @gruppen=("");
   my @user=("");
   my $num=0;
   if ($info==1){
      print "\nThe following commands can be selected with the option\n",
            "    --command-number number\n",
            "Otherwise all commands are executed (this takes time)\n\n";
   }
   open(DIRS, "<${repair_directories}")|| die "Fehler: $!";
   while (<DIRS>) {
       my $gruppen_anzahl=0;
       my $user_anzahl=0;
       chomp();   
       if ($_ eq ""){next;} # Wenn Zeile Leer, dann aussteigen
       if(/^\#/){next;} # Bei Kommentarzeichen aussteigen

       $num++;
       # replace the first occurence of the string $homedir... 
       # with the value of the variable $homedir...

       #s/\$homedir_admin/$DevelConf::homedir_admin/;
       s/\$var_lib_pfad/$DevelConf::var_lib_pfad/;
       s/\$log_files/$DevelConf::log_files/;
       s/\$apache_user/$DevelConf::apache_user/;
       s/\$apache_group/$DevelConf::apache_group/;
       s/\$homedir_all_admins/$DevelConf::homedir_all_admins/;
       s/\$homedir_pupil/${DevelConf::homedir_pupil}/;     
       s/\$homedir_teacher/$DevelConf::homedir_teacher/; 
       s/\$homedir_ws/$DevelConf::homedir_ws/; 
       s/\$attic/$DevelConf::attic/; 

       # order is important($homedir_samba must be replaced at last)    
       s/\$homedir_samba_cds/$DevelConf::homedir_samba_cds/;     
       s/\$homedir_samba_netlogon/$DevelConf::homedir_samba_netlogon/;     
       s/\$homedir_samba_progs/$DevelConf::homedir_samba_progs/;     
       s/\$homedir_samba/$DevelConf::homedir_samba/;     

       s/\$share_exams/$DevelConf::share_exams/;     
       s/\$share_teacher/$DevelConf::share_teacher/;     
       s/\$share_school/$DevelConf::share_school/;     


       s/\$share_share/$DevelConf::share_share/;     
       s/\$share_classes/$DevelConf::share_classes/;     
       s/\$share_subclasses/$DevelConf::share_subclasses/;     
       s/\$share_projects/$DevelConf::share_projects/;     

       s/\$tasks_tasks/$DevelConf::tasks_tasks/;
       s/\$tasks_teachers/$DevelConf::tasks_teachers/;     
       s/\$tasks_classes/$DevelConf::tasks_classes/;     
       s/\$tasks_subclasses/$DevelConf::tasks_subclasses/;     
       s/\$tasks_projects/$DevelConf::tasks_projects/;     
       s/\$tasks_rooms/$DevelConf::tasks_rooms/;     

       s/\$share_dir/$Language::share_dir/;     
       s/\$task_dir/$Language::task_dir/;     
       s/\$to_handoutcopy_dir/$Language::to_handoutcopy_dir/;     
       s/\$to_handoutcopy_string/$Language::to_handoutcopy_string/;     
       s/\$handout_dir/$Language::handout_dir/;     
       s/\$handout_string/$Language::handout_string/;     
       s/\$handoutcopy_dir/$Language::handoutcopy_dir/;     
       s/\$handoutcopy_string/$Language::handoutcopy_string/;     
       s/\$exam/$Language::exam/;     
       s/\$collect_dir/$Language::collect_dir/;     
       s/\$collected_dir/$Language::collected_dir/;     
       s/\$collected_string/$Language::collected_string/;     
       s/\$current_room/$Language::current_room/;     
       s/\$www_people/$DevelConf::www_people/;     
       s/\$www_classes/$DevelConf::www_classes/;     
       s/\$www_projects/$DevelConf::www_projects/;     
       s/\$www_teachers/$DevelConf::www_teachers/;     
       s/\$www_students/$DevelConf::www_students/;     
       s/\$user_attic/$Language::user_attic/;     

       
       # print only number of command when --info
       if ($info==1){
           print "Nr. $num: $_\n";
	   next;
       }

       # act only on specific lines
       if ($command_number!=0 and $command_number!=$num){
           next;    
       }

       # show what command is processed
       &titel("Command number ${num}:");
       print "$_\n";


       # Zeile zerlegen
       my ($path, $owner, $groupowner, $permission) = split(/::/);

       # Gruppen auswählen
       if (/\$klassen/) {
           # Liste ist Klassenliste
           @gruppen=@klassen;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$klassen gefunden ",
                    "(Gruppenplatzhalter: $gruppen_anzahl)\n";
           }
       }elsif (/\$raeume/) {
           # Liste ist Raumliste
           @gruppen=@raeume;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$raeume found (Group: $gruppen_anzahl)\n";
	   }
       }elsif (/\$projects/) {
           # Liste ist Projektliste
           @gruppen=@projects;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$projects found (Group: $gruppen_anzahl)\n";
	   }
       }elsif (/\$subclasses/) {
           # Liste ist Subclassliste
           @gruppen=@klassen_sub;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$subclasses found (Group: $gruppen_anzahl)\n";
	   }
       } else {
           if($Conf::log_level>=3){
              print "No \$klassen, \$raeume, $\projects or $\subclasses ",
                    "found (Group: $groupowner)\n";
           }
           @gruppen=($groupowner);
       }

       # Abbruch, falls verschiedene Gruppenplatzhalter
       if ($gruppen_anzahl > 1){
             &log_script_exit("ERROR: Gruppen-Platzhalter-Anzahl $gruppen_anzahl",
                              1,1,0,@arguments);
       }

       # User auswählen
       if ($path=~/\$schueler/) {
           if($Conf::log_level>=3){
              print "\$schueler found (Schülerliste)\n";
	   }
           # Liste ist Schülerliste
           @user=@schueler;
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$schueler found (Userplatzhalter: $user_anzahl)\n";
	   }
       } elsif (/\$lehrer/) {
           # Liste ist Lehrerliste
           @user=@lehrer;
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$lehrer found (Userplatzhalter: $user_anzahl)\n";
	   }
       }elsif (/\$workstation/) {
           # Liste ist Workstationliste
           @user=@workstations;
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$workstation found (Userplatzhalter: $user_anzahl)\n";
	   }
       }elsif (/\$members/) {
           # Liste ist leer ($members alleine macht keinen Sinn)
           @user=();
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$members found (Userplatzhalter: $user_anzahl)\n";
	   }
       } else {
           if($Conf::log_level>=3){
              print ("No \$schueler, \$lehrer \$workstations or \$members ");
              print ("found (Userplatzhalter: $owner)\n");
	   }
           @user=($owner);
       }

       # Abbruch, falls verschiedene Userplatzhalter
       if ($user_anzahl > 1){
             &log_script_exit("ERROR: User-Platzhalter-Anzahl:  $user_anzahl",
                              1,1,0,@arguments);
       }
         
       # Verzeichnis reparieren
       if($Conf::log_level>=3){
          print "   Aufruf von &repair_directory mit:\n";
          print "     Pfad:         $path\n";
          print "     Owner:        $owner\n";
          print "     Gruppe:       $groupowner\n";
          print "     Rechte:       $permission\n";
          print "     Gruppenliste: @gruppen\n";
          print "     Userliste:    @user\n";
       }
       &repair_directory($path, $owner, $groupowner, $permission, \@gruppen, \@user);
   }

   close(DIRS);
}



###############################################################################
# Reparieren eines Verzeichnisses 
###############################################################################
sub repair_directory {
   # Übergabewerte:
   # pfad(string) mit variablen $gruppe und $user
   # owner(name)
   # gruppenowner(name)
   # Dateirechte(octal, z.B. 0775)
   # Referenz auf gruppen (evtl. auch leere liste)
   # Referenz auf user (evtl. auch leere liste)

   # Übergabewerte zuweisen
   my ($path, $owner, $groupowner, $permission, $gruppen, $user) = @_;

   my $korrigieren=1;
   my $permission_to_set="";
   # Allgemeine Ersetzungen
   # $webserver
   $path=~s/\/\$webserver/$DevelConf::apache_root/;
   # $apache_user
   $owner=~s/\$apache_user/$DevelConf::apache_user/;
   # $samba
   my @userliste=();

   if($Conf::log_level>=3){
      print "Pfad mit Ersetzungen: $path\n";
   }

   foreach $gruppe (@$gruppen){
         if($Conf::log_level>=3){
            print "***** Gruppe ist $gruppe *****\n";
         }
         # Pfad sichern
         my $save_path=$path;
         # Owner sichern
         my $save_owner=$owner; 

         # Group-owner sichern
         my $save_groupowner=$groupowner; 

         # Userliste evtl. einschränken
	 if ($path=~/\$klassen/ && $path=~/\$schueler/) {
            @userliste=&fetchstudents_from_adminclass($gruppe);
            #print "Userliste: Nur Klasse\n";
	 } elsif ($path=~/\$projects/ && $path=~/\$members/) {
            @userliste=&fetchusers_from_project($gruppe);
            #print "Userliste: Nur Workstations\n";
	 } elsif ($path=~/\$raeume/ && $path=~/\$workstation/) {
            @userliste=&fetchworkstations_from_room($gruppe);
            #print "Userliste: Nur Workstations\n";
	 } else {
            my $zahl=@$user;
            if (not $zahl==0) {
               @userliste=@$user;
               #print "Userliste: Alle ($zahl)\n";
	    } else {
               @userliste=("");
               print "Userliste: User ohne Namen ($zahl User)\n";
	    }
	 }

         # Ersetzungen vornehmen von Gruppen
         # Bsp.: String $klassen mit dem Wert von $gruppe ersetzen
         $path=~s/\$klassen/$gruppe/g; 
         $path=~s/\$raeume/$gruppe/g; 
         $path=~s/\$projects/$gruppe/g; 
         $path=~s/\$subclasses/$gruppe/g; 

         $groupowner=~s/\$klassen/$gruppe/g; 
         $groupowner=~s/\$raeume/$gruppe/g;
         $groupowner=~s/\$projects/$gruppe/g;
         $groupowner=~s/\$subclasses/$gruppe/g;

      foreach $user (@userliste){
         if($Conf::log_level>=3){
            print "User ist $user\n";
         }
         # Pfad sichern
         my $save_path=$path;         
         # Owner sichern
         my $save_owner=$owner;
         
         # Grou-owner sichern
         my $save_groupowner=$groupowner;
         
         my $ownerid=0;
         my $gid=0;

         # Ersetzungen vornehmen von Usern
         $path=~s/\$schueler/$user/g; 
         $path=~s/\$lehrer/$user/g; 
         $path=~s/\$workstation/$user/g; 
         $path=~s/\$members/$user/g; 

         $owner=~s/\$schueler/$user/g; 
         $owner=~s/\$lehrer/$user/g;
         $owner=~s/\$workstation/$user/g; 
         $owner=~s/\$members/$user/g; 

         # use database
         $ownerid = &fetchdata_from_account($owner);
         if ($ownerid==-1) {
             # use ldap
	     if (not defined($ownerid=getpwnam $owner)){
                 print "WARNING: Benutzer $owner gibt es nicht!\n";
                 next;
	     }
         }

         if (not   defined ($gid = getgrnam $groupowner)) {
            print "WARNING: Gruppe $groupowner gibt es nicht!\n";
            next;
         }

         # Anlegen, falls nicht vorhanden
         # folgendes nicht mehr verwenden, da rechte unötigerweise verändert werden
         #system("install -d $path");
 
         if (not -e $path) {
            # anlegen
            mkdir $path;
            #mkdir $path, oct($permission);
         }
         # # Mehrere mit / getrente Permissions angegeben -> Liste
         if ($permission =~m/\//) {
             my @permission_list = split(/\//,$permission);
             # Dateirechte des Verzeichnises ermitteln
             my ($a,$b,$mode) = stat(${path});
             #print "Mode ist $mode\n";
             # Umwandeln in übliche Schreibweise
             $mode &=07777;
             $mode=sprintf "%04o",$mode;

             if($Conf::log_level>=2){
                print "Permissions are $mode  (Permitted: $permission)\n";
	     }
             # Falls Verzeichnisrechte gesetzt werden müssen, 
             # auf den ersten Wert setzten 
             $permission_to_set=$permission_list[0];
             # Sind die Verzeichnisrechte OK
	     foreach my $perm (@permission_list){
               if ($mode==$perm) {
               #print "VerzeichnisrechteOK\n";
               # Verzeichnisrechte wurden in der Liste der zulässigen gefunden
               # -> nicht mehr korrigieren
               $korrigieren=0;
               }
             }
         } else {
           $permission_to_set=$permission;
         }

         # Bei Bedarf Verzeichnisrechte korrigieren
         if ($korrigieren==1) {
            chmod oct($permission_to_set), $path;
            chown $ownerid, $gid, $path;
            print "  * $path $owner($ownerid) ",
                  "$groupowner($gid) $permission_to_set\n";
         } else {
            # Verzeichnisrechte nicht korrigieren
            chown $ownerid, $gid, $path;
            print "  * $path $owner($ownerid) ",
                  "$groupowner($gid) Rechte: OK\n";
            # Korrigier-Variable zurücksetzten
            $korrigieren=1;
	 }

         # Pfad wiederherstellen
         $path=$save_path;
         $owner=$save_owner;
         $groupowner=$save_groupowner;
      }

    # Pfad wiederherstellen
    $path=$save_path;
    $owner=$save_owner;
    $groupowner=$save_groupowner;
    }

}



