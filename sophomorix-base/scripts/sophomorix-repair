#!/usr/bin/perl -w
# $Id$
# This script (sophomorix-repair) is maintained by Rüdiger Beck
# It is Free Software (License GPLv3)
# If you find errors, contact the author
# jeffbeck@web.de  or  jeffbeck@gmx.de


# next
# remove symbolic links, when they are in the way of af a bind that must be created
# tausch-Schule fehlt in den bind mounts
# make option --repairlinks use the tools of a userlist, like repairbinds
# option --log-funny-files /path/to/file : list all files that should not be there in the log file
# time for bind repair: 3s for a user that is in 30 groups
#                       1s for a user that is in 3 groups


# Bibliotheken
use strict;
use Getopt::Long;
use Sophomorix::SophomorixConfig;
use Sophomorix::SophomorixBase;
use Sophomorix::SophomorixAPI;
use Sophomorix::SophomorixPgLdap;
Getopt::Long::Configure ("bundling");
use DBI;
use Sophomorix::SophomorixPgLdap qw(show_modulename
                                   );
my @arguments = @ARGV;

#my $user="";
#my $gruppe="";

my $repairhome=0;

# delete following option ???????????
my $repairbinds=0;

# binds
my $delete_bind_extension=".bind";  # default extension
my $repair_bind_extension=".bind";  # default extension
my $delete_bind_extension_do_nothing="---";
my $repair_bind_extension_do_nothing="---";
# options for binds:
my $delete_binds=$delete_bind_extension_do_nothing;
my $repair_binds=$repair_bind_extension_do_nothing;

# delete followwing option ?????????????
my $repairlinks="";

# links
my $delete_link_extension=".link";  # default extension
my $repair_link_extension=".link";  # default extension
my $delete_link_extension_do_nothing="---";
my $repair_link_extension_do_nothing="---";
# options for links:
my $delete_links=$delete_link_extension_do_nothing;
my $repair_links=$repair_link_extension_do_nothing;

my $help=0;
my $info=0;
my $filename="";
my $dateirechte=0;
my $htaccess=0;
my $command_number=0;
my $skiplock=0;
$Conf::log_level=1;


# not needed ?
my $login="";
my $classes="";
my $projects="";
my $student=0;

#my $lehrer=0;
#my $schueler=0;




###############################################################################
# Beginn
###############################################################################
# Datei, die die zu reparierenden Verzeichnisse beinhaltet
my $repair_directories="$DevelConf::devel_pfad/repair.directories";


# Parsen der Optionen
my $testopt=GetOptions(
           "help|h" => \$help,
           "info|i" => \$info,
           "verbose|v+" => \$Conf::log_level,
           "permissions" => \$dateirechte,
           "htaccess" => \$htaccess,
           "command-number=n" => \$command_number,
           "repairhome" => \$repairhome,
           "repairbinds" => \$repairbinds,
           "delete-binds:s" => \$delete_binds,
           "repair-binds:s" => \$repair_binds,
           "delete-links:s" => \$delete_links,
           "repair-links:s" => \$repair_links,
           "repairlinks=s" => \$repairlinks,
           "skiplock" => \$skiplock,
           "file|f=s" => \$filename,
           "user|u=s" => \$login,
           "class|classes|c=s" => \$classes,
           "project|projects|p=s" => \$projects,
           "student|students|s" => \$student,
          );

# binds
#if($delete_binds eq ""){
#    $delete_binds=$delete_bind_extension;
#}
#if($repair_binds eq ""){
#    $repair_binds=$repair_bind_extension;
#}
## links
#if($delete_links eq ""){
#    $delete_links=$delete_link_extension;
#}
#if($repair_links eq ""){
#    $repair_links=$repair_link_extension;
#}


# calculate extension
# $delete_binds is the option
# $delete_bind_extension is the extension used from now on
if ($delete_binds ne ""){
    $delete_bind_extension=$delete_binds;
}
if ($repair_binds ne ""){
    $repair_bind_extension=$repair_binds;
}
if ($delete_links ne ""){
    $delete_link_extension=$delete_links;
}
if ($repair_links ne ""){
    $repair_link_extension=$repair_links;
}



print "BN: >$delete_binds<  ($delete_bind_extension)\n";
print "BN: >$repair_binds<\n";
print "LN: >$delete_links<\n";
print "LN: >$repair_links<\n";

# Prüfen, ob Optionen erkannt wurden
&check_options($testopt);


if ($dateirechte==0 
    and $htaccess==0
    and $info==0
    and $repairhome==0
    and $repairbinds==0
    and $delete_binds eq $delete_bind_extension_do_nothing
    and $repair_binds eq $repair_bind_extension_do_nothing
    and $delete_links eq $delete_link_extension_do_nothing
    and $repair_links eq $repair_link_extension_do_nothing
    and $repairlinks eq "") {
   # Es muss eine Option angegeben werden, sonst hilfe
   $help=1;
}


# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlbeschreibung
   print "\n$scriptname repairs the permissions ",
         "of a sophomorix installation,\n",
         "reading the permissions from $repair_directories.\n\n";
   print('
Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i
  -f filename / --file filename

What to repair (one option must be given):

  --permissions
      (repairs permission outside of $HOME)
      Limit the repair to a command-number (show the numbers with -i):
         --command-number number

  --htaccess
      (repairs .htacces files for users,classes and projects)

  --repairhome
      (repairs $HOME/* of students and teachers)
      Limit the repair to some users:
         -u user1,user2,... / --user user1,user2,...
         -c class1,class2,... / --class class1.class2,... (teachers can be used)
         -p project1,project2,... / --project project1,project2,...
         --students

  Repairing pointers (links, bind mounts, ...)

    Remove the link/bind (Default extension is .link/.bind)

      --delete-links / --delete-links ".link-extension" 
      --delete-binds / --delete-binds ".bind-extension" 

    Repair the link/bind (Default extension is .link/.bind)

      --repair-links / --repair-links ".link-extension" 
      --repair-binds / --repair-binds ".bind-extension" 

    Limit the deletion/repair to some users:
         -u user1,user2,... / --user user1,user2,...
         -c class1,class2,... / --class class1.class2,... (teachers can be used)
         -p project1,project2,... / --project project1,project2,...
         --students

Please see the sophomorix-repair(8) man pages for full documentation
');
   exit;
   #&log_script_exit("",1,1,0,@arguments);
}

&log_script_start(@arguments);



# --file
if ($filename ne "") {
   if (-e $filename) {
      print "\nRepariere Verzeichnisse aus $filename\n";
      $repair_directories="$filename";
   } else {
      print "\n   ABBRUCH - Nichtexistierende Datei: $filename\n\n";
      &log_script_exit("Nonexisting file $filename",1,1,0,@arguments);
    }
}


# repair.directories einlesen
&titel("Reading permision data ...");
&get_alle_verzeichnis_rechte();

# fetch permission for all homes
&fetch_repairhome();

&check_verzeichnis_mkdir("${DevelConf::log_pfad_repair}");



###############################################################################
# Gruppenlisten/Userlisten erstellen
###############################################################################

# Klassen
&titel("Creating list of every AdminClass ...");
my @klassen=&fetchadminclasses_from_school("showhidden"); 
&print_list("The list of every AdminClass:",@klassen);

# Subclasses
&titel("Creating list of every AdminClass with subclasses...");
my @klassen_sub=&fetchsubclasses_from_school(); 
&print_list("The list of every AdminClass with subclasses:",@klassen_sub);

# Projects
&titel("Creating list of every Project ...");
my @projects=&fetchprojects_from_school(); 
&print_list("The list of every Project:",@projects);

# Räume
&titel("Creating list of every room ...");
my @raeume=&fetchrooms_from_school(); 
&print_list("The list of every room:",@raeume);



# Userlisten

# schueler
&titel("Creating list of every pupil ...");
#my @schueler=&get_pupils_school();
my @schueler=&fetchstudents_from_school();
&print_list("The list of every pupil:",@schueler);

# lehrer
&titel("Creating list of every teacher ...");
#my @lehrer=&get_lehrer_in_schule();
my @lehrer=&fetchstudents_from_adminclass(${DevelConf::teacher});
&print_list("The list of every teacher:",@lehrer);

# admins
&titel("Creating list of every administrator ...");
#my @lehrer=&get_lehrer_in_schule();
my @admins=&fetchadministrators_from_school();
&print_list("The list of every administrator:",@admins);

# workstations
&titel("Creating list of every workstation ...");
#my @workstations=&get_workstations_in_schule();
#my @workstations=&get_workstations_school();
my @workstations=&fetchworkstations_from_school();
&print_list("The list of every workstation:",@workstations);








# do something


# --permissions
if ($dateirechte==1 or $info==1) {
   &repair_directories();
}


# --htaccess
if ($htaccess==1){
   &repair_htaccess();
}


# --repairhome type
if ($repairhome==1){
    # fetch fermission for all homes
    my $ref_repair=&fetch_repairhome();

    my @users=();
    # create userlist
    if ($login ne ""
        or $classes ne ""
        or $projects ne ""
        or $student==1
       ){
       &titel("Checking login names ...");
       @users=&create_userlist($login,$classes,1,$projects,1,$student,
                               0,0,0,1);
    } else {
       # teachers and students
       @users=(@lehrer,@schueler,@admins);
    }
    foreach my $user (@users){
        print "Repairing \$HOME of $user\n";
        &repair_repairhome($user);
    }
}


# The following options call manage_pointers:
# --create-links
# --delete-links
# --repair-links
# --create-binds
# --delete-binds
# --repair-binds
#if ($repairbinds==1){

if (
    $delete_binds ne $delete_bind_extension_do_nothing or
    $repair_binds ne $repair_bind_extension_do_nothing or
    $delete_links ne $delete_link_extension_do_nothing or
    $repair_links ne $repair_link_extension_do_nothing
   ){
    my @users=();
    # create userlist
    if ($login ne ""
        or $classes ne ""
        or $projects ne ""
        or $student==1
       ){
       &titel("Checking login names ...");
       @users=&create_userlist($login,$classes,1,$projects,1,$student,
                               0,0,0,1);
    } else {
       # teachers and students
       @users=(@lehrer,@schueler,@admins);
    }
    foreach my $user (@users){
        print "Managing pointers (bind, links, ...) of $user\n";
        &manage_pointers($user);
    }
}


# --repairlinks
if ($repairlinks ne ""){
    my $login = $repairlinks;
    my ($home) = &fetchdata_from_account($login);
    my $share_dir=$home."/".$Language::share_dir;
    my %share_dirs=();
    my $exists_string="Exists";

    # repairing links
    my @list=&Sophomorix::SophomorixPgLdap::pg_get_group_list($login);
        print "Repairing Links in $share_dir\n";
    foreach my $group (@list){
        my ($group_type)=&pg_get_group_type($group);
    

        # creates __tauschen/tausch-schule for everybody
        &Sophomorix::SophomorixBase::create_school_link($login);
        &create_share_link($login,$group,$group,$group_type);
    }

    print "-----------------------------------------------------------------------\n";
    print "Analyzing links of $login in $share_dir\n";
    print "-----------------------------------------------------------------------\n";
    if (not -e $share_dir){
        &log_script_exit("Nonexisting dir $share_dir",1,1,0,@arguments);
    }
    opendir DIR, $share_dir or die "Cannot open $share_dir: $!";
    foreach my $file (readdir DIR) {
        if ($file eq "." or $file eq ".."){
	    next;
        }
        print "   Share Links: $file";
        # remove string, so that the class is shown
        $file =~ s/$Language::share_string//;
        $share_dirs{$file}=$exists_string;
        print " ($file)\n";
    }
    closedir DIR;

#     print "-----------------------------------------------------------------------\n";
#     print "Class             |SHARE| \n";
#     print "-----------------------------------------------------------------------\n";
#     my @classes=&fetch_my_adminclasses($login);
#     @classes = sort @classes;
#     foreach my $class (@classes){
#         my $share_link_ok="Missing";
#         if (exists $share_dirs{$class}){
#             $share_link_ok="OK";
#             $share_dirs{$class}="Good";
#         }
#         printf "%-17s %-5s \n",$class,$share_link_ok;
#     }

#     # set all Standard Links to Good
#     $share_dirs{$Language::school}="Good";
#     $share_dirs{$Language::teacher}="Good";
#     # check, if the remaining files are projects
#     print "-----------------------------------------------------------------------\n";
#     print "Project           |SHARE| \n";
#     print "-----------------------------------------------------------------------\n";
#     while( my ($k, $v) = each(%share_dirs) ) {
#         my $correct="Missing";
# 	if ($v eq $exists_string){
#             # check if  user is in project correctly
# 	    my @users=&fetchusers_from_project($k);
#             foreach my $user (@users){
#                 if ($login eq $user){
#                    # That is OK
# 		    $correct="OK";
#                 }
#             }
#             printf "%-17s %-5s \n",$k,$correct;
#         }
#      }
#     print "-----------------------------------------------------------------------\n";

#     print "-----------------------------------------------------------------------\n";
#     print "Gruppe            |SHARE| \n";
#     print "-----------------------------------------------------------------------\n";
#     my @group_list=&Sophomorix::SophomorixPgLdap::pg_get_group_list($login);
#     foreach my $group (@group_list){
#         printf "%-17s ",$group;
#         if ($group eq $DevelConf::teacher){
#             print "not checked\n";
#         } elsif (exists $share_dirs{$group}){
#             print "OK\n";
#         } else {
#             print "---\n";
#         }
#     }

}





&log_script_end(@arguments);









###############################################################################
# Erzeugt für jede Zeile von repair.directories einen Befehl
###############################################################################


sub repair_htaccess {
  if ($DevelConf::create_www==1) {
     print "Repairing htaccess files of adminclasses:\n";
     foreach my $group (@klassen){
        print "   ${group}:\n";
        my ($access)=&fetchhtaccess_from_group($group);
        &set_htaccess_for_group($group,$access);
     }
     print "Repairing htaccess files of projects:\n";
     foreach my $group (@projects){
        print "   ${group}:\n";
        my ($access)=&fetchhtaccess_from_group($group);
        &set_htaccess_for_group($group,$access);
     }
     print "Repairing htaccess files of students:\n";
     foreach my $student (@schueler){
        print "   ${student}:\n";
        my ($access)=&fetchhtaccess_from_user($student);
        &set_htaccess_for_user($student,$access);
     }
     print "Repairing htaccess files of teachers:\n";
     foreach my $teacher (@lehrer){
        print "   ${teacher}:\n";
        my ($access)=&fetchhtaccess_from_user($teacher);
        &set_htaccess_for_user($teacher,$access);
     }
 } else {
     print "sophomorix is configured not to repair .htaccess files\n";
 }
}


sub set_htaccess_for_user {
    my ($user,$access) = @_;
    if ($access eq "user-public-upload"){
        &user_public_upload($user);
    } elsif ($access eq "user-private-upload"){
        &user_private_upload($user);
    } elsif ($access eq "user-public-noupload"){
        &user_public_noupload($user);
    } elsif ($access eq "user-private-noupload"){
        &user_private_noupload($user);
    } else {
        # standard
        my ($home,$type)=
          &Sophomorix::SophomorixPgLdap::fetchdata_from_account($user);
        if ($type eq "teacher"){
            &user_private_upload($user);
        } elsif ($type eq "student"){
            &user_private_noupload($user);
        } else {
            # no type 
            print "     * WARNING: .htacess NOT created!\n";
            print "     *           NO standard for type ${type}!\n";
        }
    }
}

sub set_htaccess_for_group {
    my ($group,$access) = @_;
    if ($access eq "group-public-upload"){
        &group_public_upload($group);
    } elsif ($access eq "group-private-upload"){
        &group_private_upload($group);
    } elsif ($access eq "group-public-noupload"){
        &group_public_noupload($group);
    } elsif ($access eq "group-private-noupload"){
        &group_private_noupload($group);
    } else {
        # standard
        &group_private_noupload($group);
    }
}


sub repair_directories {
   # Liste mit einem Element, dass die Schleifen EINMAL durchlaufen werden
   my @gruppen=("");
   my @user=("");
   my $num=0;
   if ($info==1){
      print "\nThe following commands can be selected with the option\n",
            "    --command-number number\n",
            "Otherwise all commands are executed (this takes time)\n\n";
   }
   open(DIRS, "<${repair_directories}")|| die "Fehler: $!";
   while (<DIRS>) {
       my $gruppen_anzahl=0;
       my $user_anzahl=0;
       chomp();   
       if ($_ eq ""){next;} # Wenn Zeile Leer, dann aussteigen
       if(/^\#/){next;} # Bei Kommentarzeichen aussteigen

       $num++;
       # replace the first occurence of the string $homedir... 
       # with the value of the variable $homedir...

       #s/\$homedir_admin/$DevelConf::homedir_admin/;
       s/\$var_lib_pfad/$DevelConf::var_lib_pfad/;
       s/\$log_files/$DevelConf::log_files/;
       s/\$apache_user/$DevelConf::apache_user/;
       s/\$apache_group/$DevelConf::apache_group/;
       s/\$homedir_all_admins/$DevelConf::homedir_all_admins/;
       s/\$homedir_pupil/${DevelConf::homedir_pupil}/;     
       s/\$homedir_teacher/$DevelConf::homedir_teacher/; 
       s/\$homedir_ws/$DevelConf::homedir_ws/; 
       s/\$attic/$DevelConf::attic/; 

       # order is important($homedir_samba must be replaced at last)    
       s/\$homedir_samba_cds/$DevelConf::homedir_samba_cds/;     
       s/\$homedir_samba_netlogon/$DevelConf::homedir_samba_netlogon/;     
       s/\$homedir_samba_progs/$DevelConf::homedir_samba_progs/;     
       s/\$homedir_samba/$DevelConf::homedir_samba/;     

       s/\$share_exams/$DevelConf::share_exams/;     
       s/\$share_teacher/$DevelConf::share_teacher/;     
       s/\$share_school/$DevelConf::share_school/;     


       s/\$share_share/$DevelConf::share_share/;     
       s/\$share_classes/$DevelConf::share_classes/;     
       s/\$share_subclasses/$DevelConf::share_subclasses/;     
       s/\$share_projects/$DevelConf::share_projects/;     

       s/\$tasks_tasks/$DevelConf::tasks_tasks/;
       s/\$tasks_teachers/$DevelConf::tasks_teachers/;     
       s/\$tasks_classes/$DevelConf::tasks_classes/;     
       s/\$tasks_subclasses/$DevelConf::tasks_subclasses/;     
       s/\$tasks_projects/$DevelConf::tasks_projects/;     
       s/\$tasks_rooms/$DevelConf::tasks_rooms/;     

       s/\$share_dir/$Language::share_dir/;     
       s/\$task_dir/$Language::task_dir/;     
       s/\$to_handoutcopy_dir/$Language::to_handoutcopy_dir/;     
       s/\$to_handoutcopy_string/$Language::to_handoutcopy_string/;     
       s/\$handout_dir/$Language::handout_dir/;     
       s/\$handout_string/$Language::handout_string/;     
       s/\$handoutcopy_dir/$Language::handoutcopy_dir/;     
       s/\$handoutcopy_string/$Language::handoutcopy_string/;     
       s/\$exam/$Language::exam/;     
       s/\$collect_dir/$Language::collect_dir/;     
       s/\$collected_dir/$Language::collected_dir/;     
       s/\$collected_string/$Language::collected_string/;     
       s/\$current_room/$Language::current_room/;     
       s/\$www_people/$DevelConf::www_people/;     
       s/\$www_classes/$DevelConf::www_classes/;     
       s/\$www_projects/$DevelConf::www_projects/;     
       s/\$www_teachers/$DevelConf::www_teachers/;     
       s/\$www_students/$DevelConf::www_students/;     
       s/\$user_attic/$Language::user_attic/;     
       
       # print only number of command when --info
       if ($info==1){
           print "Nr. $num: $_\n";
	   next;
       }

       # act only on specific lines
       if ($command_number!=0 and $command_number!=$num){
           next;    
       }

       # show what command is processed
       &titel("Command number ${num}:");
       print "$_\n";

       # Zeile zerlegen
       my ($path, $owner, $groupowner, $permission) = split(/::/);

       # Gruppen auswählen
       if (/\$klassen/) {
           # Liste ist Klassenliste
           @gruppen=@klassen;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$klassen gefunden ",
                    "(Gruppenplatzhalter: $gruppen_anzahl)\n";
           }
       }elsif (/\$raeume/) {
           # Liste ist Raumliste
           @gruppen=@raeume;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$raeume found (Group: $gruppen_anzahl)\n";
	   }
       }elsif (/\$projects/) {
           # Liste ist Projektliste
           @gruppen=@projects;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$projects found (Group: $gruppen_anzahl)\n";
	   }
       }elsif (/\$subclasses/) {
           # Liste ist Subclassliste
           @gruppen=@klassen_sub;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$subclasses found (Group: $gruppen_anzahl)\n";
	   }
       } else {
           if($Conf::log_level>=3){
              print "No \$klassen, \$raeume, $\projects or $\subclasses ",
                    "found (Group: $groupowner)\n";
           }
           @gruppen=($groupowner);
       }

       # Abbruch, falls verschiedene Gruppenplatzhalter
       if ($gruppen_anzahl > 1){
             &log_script_exit("ERROR: Gruppen-Platzhalter-Anzahl $gruppen_anzahl",
                              1,1,0,@arguments);
       }

       # User auswählen
       if ($path=~/\$schueler/) {
           if($Conf::log_level>=3){
              print "\$schueler found (Schülerliste)\n";
	   }
           # Liste ist Schülerliste
           @user=@schueler;
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$schueler found (Userplatzhalter: $user_anzahl)\n";
	   }
       } elsif (/\$lehrer/) {
           # Liste ist Lehrerliste
           @user=@lehrer;
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$lehrer found (Userplatzhalter: $user_anzahl)\n";
	   }
       }elsif (/\$workstation/) {
           # Liste ist Workstationliste
           @user=@workstations;
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$workstation found (Userplatzhalter: $user_anzahl)\n";
	   }
       }elsif (/\$members/) {
           # Liste ist leer ($members alleine macht keinen Sinn)
           @user=();
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$members found (Userplatzhalter: $user_anzahl)\n";
	   }
       } else {
           if($Conf::log_level>=3){
              print ("No \$schueler, \$lehrer \$workstations or \$members ");
              print ("found (Userplatzhalter: $owner)\n");
	   }
           @user=($owner);
       }

       # Abbruch, falls verschiedene Userplatzhalter
       if ($user_anzahl > 1){
             &log_script_exit("ERROR: User-Platzhalter-Anzahl:  $user_anzahl",
                              1,1,0,@arguments);
       }
         
       # Verzeichnis reparieren
       if($Conf::log_level>=3){
          print "   Aufruf von &repair_directory mit:\n";
          print "     Pfad:         $path\n";
          print "     Owner:        $owner\n";
          print "     Gruppe:       $groupowner\n";
          print "     Rechte:       $permission\n";
          print "     Gruppenliste: @gruppen\n";
          print "     Userliste:    @user\n";
       }
       &repair_directory($path, $owner, $groupowner, $permission, \@gruppen, \@user);
   }

   close(DIRS);
}



###############################################################################
# Reparieren eines bind mounts 
###############################################################################

sub create_link {
    # create the link!
    my ($link_target,$link_name) = @_;
    print "Creating $link_name pointing to $link_target";
    ###symlink $link_target, $link_name;
}


sub create_bind {
    # do the mount!
    my ($olddir,$newdir) = @_;
    # ?????????????? if newdir is a link, remove it!
    my $mkdir_command = "mkdir $newdir";
    my $mount_command = "mount --bind $olddir $newdir";
    print "      $mkdir_command\n";
    ###system("$mkdir_command");
    print "      $mount_command\n";
    ###system("$mount_command");
}



sub delete_link {
    # delete the link!
    my ($link_target,$link_name) = @_;
    my $rm_command = "rm $link_name &> /dev/null";
    print "      $rm_command\n";
    ###system("$rm_command");
}


sub delete_bind {
    # undo mounts of newdir, even if mounted multiple times
    my ($olddir,$newdir) = @_;
    my $umount_command = "umount $newdir &> /dev/null";
    my $rmdir_command = "rmdir $newdir &> /dev/null";
    my $return=0;
    ###while ($return==0){
        print "      $umount_command\n";
        ###$return=system("$umount_command");
    ###}
    print "      $rmdir_command\n";
    ###system("$rmdir_command");
}


sub update_pointer_school {
    my ($login) = @_;
    my ($home)=&Sophomorix::SophomorixPgLdap::fetchdata_from_account($login);
    if ($home ne ""){
       # remember and remove immutable bit on parent dir
       my $parent_dir = $home."/${Language::share_dir}";
       my $immutable_bit=&fetch_immutable_bit($parent_dir);
       &set_immutable_bit($parent_dir,0);

       my $link_name=$home.
        "/${Language::share_dir}/${Language::share_string}".
        "${Language::school}";

       my $link_target=$DevelConf::share_school;

       # Link to school
       if($Conf::log_level>=2){
           print "   Link name (school): $link_name\n";
           print "   Target    (school): $link_target\n";
       }

#       symlink $link_target, $link_name;


       &set_immutable_bit($parent_dir,$immutable_bit);

    }
}




sub update_pointer {
    my ($login,$share_name,$share_long_name,$type) = @_;
    my $old_dir="";   # was $link_target 
    my $old_dir_tasks=""; # was $link_target_tasks
    my ($homedir,$pri_group)=
        &Sophomorix::SophomorixPgLdap::fetchdata_from_account($login);

    # replace teachers with language term
    if ($share_name  eq ${DevelConf::teacher}){
        $share_long_name=${Language::teacher};     
    }

    # use shortname as longname if not given
    if (not defined $share_long_name){
        $share_long_name=$share_name;
    }

    # project is standard
    if (not defined $type or $type eq ""){
	$type="project";
    }

    # Only act if uid is valid
    if ($homedir ne ""){
       # save immutable bit on share_dir and unset it
       my $immutable_share_dir=$homedir."/${Language::share_dir}";
       my $immutable_share_bit=&fetch_immutable_bit($immutable_share_dir);
       &set_immutable_bit($immutable_share_dir,0);

       # save immutable bit on task_dir and unset it
       my $immutable_task_dir=$homedir."/${Language::task_dir}";
       my $immutable_task_bit=&fetch_immutable_bit($immutable_task_dir);
       &set_immutable_bit($immutable_task_dir,0);


       # basenames without extensions
       my $basename_pointer=$homedir.
          "/${Language::share_dir}/${Language::share_string}".
          "${share_long_name}";

       my $basename_pointer_tasks=$homedir.
          "/${Language::task_dir}/${Language::task_string}".
          "${share_long_name}";

       my $new_dir_delete=$basename_pointer.$delete_bind_extension;
       my $new_dir_repair=$basename_pointer.$repair_bind_extension;
       my $new_dir_delete_tasks=$basename_pointer_tasks.$delete_bind_extension;
       my $new_dir_repair_tasks=$basename_pointer_tasks.$repair_bind_extension;

       my $link_name_delete=$basename_pointer.$delete_link_extension;
       my $link_name_repair=$basename_pointer.$repair_link_extension;
       my $link_name_delete_tasks=$basename_pointer_tasks.$delete_link_extension;
       my $link_name_repair_tasks=$basename_pointer_tasks.$repair_link_extension;


       # $new_dir for 
#       my $new_dir=$homedir.
#          "/${Language::share_dir}/${Language::share_string}".
#          "${share_long_name}"."$bind_extension";   
#
#       my $new_dir_tasks=$homedir.
#          "/${Language::task_dir}/${Language::task_string}".
#          "${share_long_name}"."$bind_extension";



       # decide path names according to user type
       if ($type eq "project"){
           # project
           $old_dir="${DevelConf::share_projects}/${share_name}";
           $old_dir_tasks="${DevelConf::tasks_projects}/${share_name}";
       } elsif ($type eq "adminclass"){
           # class
           $old_dir="${DevelConf::share_classes}/${share_name}";
           $old_dir_tasks="${DevelConf::tasks_classes}/${share_name}";
       } elsif ($type eq "teacher"){
           # teacher
           $old_dir="${DevelConf::share_teacher}";
           $old_dir_tasks="${DevelConf::tasks_teachers}";
       } elsif ($type eq "subclass"){
           # subclass
           $old_dir="${DevelConf::share_subclasses}/${share_name}";
           $old_dir_tasks="${DevelConf::tasks_subclasses}/${share_name}";
       } elsif ($type eq "room"){
           # room
           $old_dir_tasks="${DevelConf::tasks_rooms}/${share_name}";
       } else {
           print "Unknown type $type\n\n";
	   return 0;
       }

       ##################################################
       # Link to share (all but workstations)
       ##################################################
       if ($type ne "room"){
           if($Conf::log_level>=2){
               print "   Newdir  (share): $new_dir_delete\n";
               print "   Newdir  (share): $new_dir_repair\n";
               print "   Olddir  (share): $old_dir\n";
           }
           if (-d $old_dir){
               if($Conf::log_level>=2){
                   print "   Creating bind mount for user $login ",
                         "to $type ${old_dir}.\n";
               }

               ##################################################
               # delete and recreate bindmounts/links
               ##################################################
               # --delete-links
               if ($delete_link_extension ne $delete_link_extension_do_nothing){
                   &delete_link($old_dir,$link_name_delete);
               }

               # --delete-binds
               if ($delete_bind_extension ne $delete_bind_extension_do_nothing){
                   &delete_bind($old_dir,$new_dir_delete);
               }

               # --repair-links
               if ($repair_link_extension ne $repair_link_extension_do_nothing){
                   &delete_link($old_dir,$link_name_repair);
                   &delete_bind($old_dir,$link_name_repair);
                   &create_link($old_dir,$link_name_repair);
               }

               # --repair-binds
               if ($repair_bind_extension ne $repair_bind_extension_do_nothing){
                   &delete_link($old_dir,$new_dir_repair);
                   &delete_bind($old_dir,$new_dir_repair);
                   &create_bind($old_dir,$new_dir_repair);
               }
           } else {
               print "   NOT creating bind mount to ",
                     "nonexisting/nondirectory $old_dir\n";
           }
       }

       ##################################################
       # Link to tasks (all users)
       ##################################################
       if($Conf::log_level>=2){
           print "   Newdir  (tasks): $new_dir_delete_tasks\n";
           print "   Newdir  (tasks): $new_dir_repair_tasks\n";
           print "   Olddir  (tasks): $old_dir_tasks\n";
       }
       if ($type eq "room"){
          # create the share_dir on the fly
          &setup_verzeichnis("\$tasks_rooms/\$raeume",
                             "$old_dir_tasks");
       }

       if (-d $old_dir_tasks){
           if($Conf::log_level>=2){
               print "   Creating bind mont for user $login ",
                     "to $type ${old_dir_tasks}.\n";
           }

           ##################################################
           # delete and recreate bindmounts/links
           ##################################################
           # --delete-links
           if ($delete_link_extension ne $delete_link_extension_do_nothing){
               &delete_link($old_dir_tasks,$link_name_delete_tasks);
           }

           # --delete-binds
           if ($delete_bind_extension ne $delete_bind_extension_do_nothing){
               &delete_bind($old_dir_tasks,$new_dir_delete_tasks);
           }

           # --repair-links
           if ($repair_link_extension ne $repair_link_extension_do_nothing){
               &delete_link($old_dir_tasks,$link_name_repair_tasks);
               &delete_bind($old_dir_tasks,$link_name_repair_tasks);
               &create_link($old_dir_tasks,$link_name_repair_tasks);
           }

           # --repair-binds
           if ($repair_bind_extension ne $repair_bind_extension_do_nothing){
               &delete_link($old_dir,$new_dir_repair_tasks);
               &delete_bind($old_dir,$new_dir_repair_tasks);
               &create_bind($old_dir,$new_dir_repair_tasks);
           }

           # delete an recreate bind mounts  ?????????????????
           #&delete_bind($old_dir_tasks,$new_dir_tasks);
           #&create_bind($old_dir_tasks,$new_dir_tasks);
       } else {
           print "   NOT creating bind mount to ",
                 "nonexisting/nondirectory $old_dir_tasks\n";
       }
       # restore immutable bit
       &set_immutable_bit($immutable_share_dir,$immutable_share_bit);
       &set_immutable_bit($immutable_task_dir,$immutable_task_bit);
    } else {
        print "   NOT removing directories: ",
              "Home of user $login not known.\n";
    }
}




sub manage_pointers {
    my ($login)= @_;
    print "  * Starting manage_pointers\n";
    my ($home) = &fetchdata_from_account($login);
    my $share_dir=$home."/".$Language::share_dir;
    my $exists_string="Exists";
    my %mandatory_binds=();

    # repairing pointers
    my @list=&Sophomorix::SophomorixPgLdap::pg_get_group_list($login);
        print "Repairing pointers in $share_dir\n";
    my $count=1;
    foreach my $group (@list){
        my ($group_type)=&pg_get_group_type($group);
    
        print " $count)  $group ($group_type)\n";

        #
        # creates __tauschen/tausch-schule for everybody
#        &Sophomorix::SophomorixBase::create_school_link($login);
#        &create_share_link($login,$group,$group,$group_type);


         # next line repairs bind mount
         #&update_pointer($login,$group,$group,$group_type,$bind_extension,$link_extension);
         &update_pointer($login,$group,$group,$group_type);
         # school dir
         &update_pointer_school($login);
        $mandatory_binds{$group}="mandatory";
        $count++;
    }

    print "-----------------------------------------------------------------------\n";
    print "Checking binds of $login in $share_dir\n";
    print "-----------------------------------------------------------------------\n";
    if (not -e $share_dir){
        &log_script_exit("Nonexisting dir $share_dir",1,1,0,@arguments);
    }
    opendir DIR, $share_dir or die "Cannot open $share_dir: $!";
    my @files=();
    foreach my $file (readdir DIR) {
        push @files, $file;
    }
    @files = sort @files;

    $count=1;
    foreach my $file (@files) {
        if ($file eq "." or $file eq ".."){
	    next;
        }

        my $group = $file;
        # remove string, so that the group is shown
        $group =~ s/$Language::share_string//;

        #
        # check here if it is a dir and mounted correctly ??????????????
        #
        if (exists $mandatory_binds{$group}){
            print "   $count) $file ($group)\n";
        } else {
            # ???????????? avoid ? when tausch-Lehrer and taush-Schule
            print "?  $count) $file ($group)\n";
        }

        $count++;
    }
    closedir DIR;
    return;
}

###############################################################################
# Reparieren eines Verzeichnisses 
###############################################################################

sub repair_directory {
   # Übergabewerte:
   # pfad(string) mit variablen $gruppe und $user
   # owner(name)
   # gruppenowner(name)
   # Dateirechte(octal, z.B. 0775)
   # Referenz auf gruppen (evtl. auch leere liste)
   # Referenz auf user (evtl. auch leere liste)

   # Übergabewerte zuweisen
   my ($path, $owner, $groupowner, $permission, $gruppen, $user) = @_;

   my $korrigieren=1;
   my $permission_to_set="";
   # Allgemeine Ersetzungen
   # $webserver
   $path=~s/\/\$webserver/$DevelConf::apache_root/;
   # $apache_user
   $owner=~s/\$apache_user/$DevelConf::apache_user/;
   # $samba
   my @userliste=();

   if($Conf::log_level>=3){
      print "Pfad mit Ersetzungen: $path\n";
   }

   foreach my $gruppe (@$gruppen){
         if($Conf::log_level>=3){
            print "***** Gruppe ist $gruppe *****\n";
         }
         # Pfad sichern
         my $save_path=$path;
         # Owner sichern
         my $save_owner=$owner; 

         # Group-owner sichern
         my $save_groupowner=$groupowner; 

         # Userliste evtl. einschränken
	 if ($path=~/\$klassen/ && $path=~/\$schueler/) {
            @userliste=&fetchstudents_from_adminclass($gruppe);
            #print "Userliste: Nur Klasse\n";
	 } elsif ($path=~/\$projects/ && $path=~/\$members/) {
            @userliste=&fetchusers_from_project($gruppe);
            #print "Userliste: Nur Workstations\n";
	 } elsif ($path=~/\$raeume/ && $path=~/\$workstation/) {
            @userliste=&fetchworkstations_from_room($gruppe);
            #print "Userliste: Nur Workstations\n";
	 } else {
            my $zahl=@$user;
            if (not $zahl==0) {
               @userliste=@$user;
               #print "Userliste: Alle ($zahl)\n";
	    } else {
               @userliste=("");
               print "Userliste: User ohne Namen ($zahl User)\n";
	    }
	 }

         # Ersetzungen vornehmen von Gruppen
         # Bsp.: String $klassen mit dem Wert von $gruppe ersetzen
         $path=~s/\$klassen/$gruppe/g; 
         $path=~s/\$raeume/$gruppe/g; 
         $path=~s/\$projects/$gruppe/g; 
         $path=~s/\$subclasses/$gruppe/g; 

         $groupowner=~s/\$klassen/$gruppe/g; 
         $groupowner=~s/\$raeume/$gruppe/g;
         $groupowner=~s/\$projects/$gruppe/g;
         $groupowner=~s/\$subclasses/$gruppe/g;

      foreach $user (@userliste){
         if($Conf::log_level>=3){
            print "User ist $user\n";
         }
         # Pfad sichern
         my $save_path=$path;         
         # Owner sichern
         my $save_owner=$owner;
         
         # Grou-owner sichern
         my $save_groupowner=$groupowner;
         
         my $ownerid=0;
         my $gid=0;

         # Ersetzungen vornehmen von Usern
         $path=~s/\$schueler/$user/g; 
         $path=~s/\$lehrer/$user/g; 
         $path=~s/\$workstation/$user/g; 
         $path=~s/\$members/$user/g; 

         $owner=~s/\$schueler/$user/g; 
         $owner=~s/\$lehrer/$user/g;
         $owner=~s/\$workstation/$user/g; 
         $owner=~s/\$members/$user/g; 

         # use database
         ($a,$a,$a,$a,$ownerid) = 
            &Sophomorix::SophomorixPgLdap::fetchdata_from_account($owner);
         if ($ownerid==-1) {
             # use ldap
	     if (not defined($ownerid=getpwnam $owner)){
                 print "WARNING: Benutzer $owner gibt es nicht!\n";
                 next;
	     }
         }

         if (not   defined ($gid = getgrnam $groupowner)) {
            print "WARNING: Gruppe $groupowner gibt es nicht!\n";
            next;
         }

         # Anlegen, falls nicht vorhanden
         # folgendes nicht mehr verwenden, da rechte unötigerweise verändert werden
         #system("install -d $path");
 
         if (not -e $path) {
            # anlegen
            mkdir $path;
            #mkdir $path, oct($permission);
         }
         # # Mehrere mit / getrente Permissions angegeben -> Liste
         if ($permission =~m/\//) {
             my @permission_list = split(/\//,$permission);
             # Dateirechte des Verzeichnises ermitteln
             my ($a,$b,$mode) = stat(${path});
             #print "Mode ist $mode\n";
             # Umwandeln in übliche Schreibweise
             $mode &=07777;
             $mode=sprintf "%04o",$mode;

             if($Conf::log_level>=2){
                print "Permissions are $mode  (Permitted: $permission)\n";
	     }
             # Falls Verzeichnisrechte gesetzt werden müssen, 
             # auf den ersten Wert setzten 
             $permission_to_set=$permission_list[0];
             # Sind die Verzeichnisrechte OK
	     foreach my $perm (@permission_list){
               if ($mode==$perm) {
               #print "VerzeichnisrechteOK\n";
               # Verzeichnisrechte wurden in der Liste der zulässigen gefunden
               # -> nicht mehr korrigieren
               $korrigieren=0;
               }
             }
         } else {
           $permission_to_set=$permission;
         }

         # Bei Bedarf Verzeichnisrechte korrigieren
         if ($korrigieren==1) {
            chmod oct($permission_to_set), $path;
            chown $ownerid, $gid, $path;
            print "  * $path $owner($ownerid) ",
                  "$groupowner($gid) $permission_to_set\n";
         } else {
            # Verzeichnisrechte nicht korrigieren
            chown $ownerid, $gid, $path;
            print "  * $path $owner($ownerid) ",
                  "$groupowner($gid) Rechte: OK\n";
            # Korrigier-Variable zurücksetzten
            $korrigieren=1;
	 }

         # Pfad wiederherstellen
         $path=$save_path;
         $owner=$save_owner;
         $groupowner=$save_groupowner;
      }

    # Pfad wiederherstellen
    $path=$save_path;
    $owner=$save_owner;
    $groupowner=$save_groupowner;
    }

}



