#!/usr/bin/perl -w
# Dieses Script (sophomorix-repair) wurde von Rüdiger Beck erstellt
# Es ist freie Software
# Bei Fehlern wenden Sie sich bitte an mich.
# jeffbeck@web.de  oder  jeffbeck@gmx.de


# Bibliotheken
use strict;
use Getopt::Long;
use Sophomorix::SophomorixConfig;
use Sophomorix::SophomorixBase;
use Sophomorix::SophomorixAPI;
use Sophomorix::SophomorixPgLdap;
Getopt::Long::Configure ("bundling");

use DBI;

# Einlesen der Konfigurationsdatei für Entwickler
#{ package DevelConf ; do "/etc/sophomorix/devel/user/sophomorix-devel.conf"}

# jeffbecks Bibliothek und
# Einlesen der Konfigurationsdatei
#require "${DevelConf::library_pfad}/sophomorix-lib";


# ===========================================================================
# Loading the db-Module, list of functions
# ===========================================================================
# list of functions to load if db is 'files'
use if ${DevelConf::db_backend} eq 'files' , 
    'Sophomorix::SophomorixFiles' => qw(show_modulename
                                       );
# list of functions to load if db is 'pgldap'
use if ${DevelConf::db_backend} eq 'pgldap' , 
    'Sophomorix::SophomorixPgLdap' => qw(show_modulename
                                         pg_get_adminclasses
                                       );



# ===========================================================================
# Loading the sys-db-Module, list of functions
# ===========================================================================
# list of functions to load if sys_db is 'files'
use if ${DevelConf::sys_db} eq 'files' , 
    'Sophomorix::SophomorixSYSFiles' => qw(show_sys_modulename
                                          );

# list of functions to load if sys_db is 'pgldap'
use if ${DevelConf::sys_db} eq 'pgldap' , 
    'Sophomorix::SophomorixSYSPgLdap' => qw(show_sys_modulename
                                          );


# show the Database Modules that are loaded
&show_modulename();
&show_sys_modulename();


my $string_link="";
my $string_public_html="";


my $user="";
my $klasse="";
my $gruppe="";



my $help=0;
my $info=0;
my $filename="";
my $dateirechte=0;
my $schueler=0;
my $lehrer=0;
my $login="";
my $command_number=0;
$Conf::log_level=1;


################################################################################
# Beginn
################################################################################
# Datei, die die zu reparierenden Verzeichnisse beinhaltet
my $repair_directories="$DevelConf::devel_pfad/repair.directories";


# Parsen der Optionen
my $testopt=GetOptions(
           "help|h" => \$help,
           "info|i" => \$info,
           "verbose|v+" => \$Conf::log_level,
           "permissions|p" => \$dateirechte,
#           "schueler" => \$schueler,
#           "lehrer" => \$lehrer,
           "command-number=n" => \$command_number,
           "login|l=s" => \$login,
           "file|f=s" => \$filename
          );

# Prüfen, ob Optionen erkannt wurden
&check_options($testopt);


if ($dateirechte==0 and $info==0 and $command_number==0) {
   # Es muss eine Option angegeben werden, sonst hilfe
   $help=1;
#   print "\nYou must specify one of the following options:\n";
#   print "\n   -p\n";
}


# --help
if ($help==1) {
   # Scriptname ermitteln
   my @list = split(/\//,$0);
   my $scriptname = pop @list;
   # Befehlbeschreibung
   print "\n$scriptname repairs the permissions of a sophomorix installation,\n",
         "reading the permissions from $repair_directories.\n\n";
   print('
Options
  -h  / --help
  -v  / --verbose
  -vv / --verbose --verbose
  -i
  -f filename / --file filename
  --command-number number
  -p  / --permissions
  --acl (Todo)
  --login user (Todo)
  --schueler (Todo)
  --lehrer (Todo)

Please see the sophomorix-repair(8) man pages for full documentation
');
   exit;
}


# --file
if ($filename ne "") {
   if (-e $filename) {
      print "\nRepariere Verzeichnisse aus $filename\n";
      $repair_directories="$filename";
   } else {
      print "\n   ABBRUCH - Nichtexistierende Datei: $filename\n\n";
      exit;
    }
}


# repair.directories einlesen
&titel("Reading permision data ...");
&get_alle_verzeichnis_rechte();


################################################################################
# Gruppenlisten/Userlisten erstellen
################################################################################

# Klassen
&titel("Creating list of every AdminClass ...");
#my @klassen=&get_adminclasses_school(); 
#my @klassen=&pg_get_adminclasses(); 
my @klassen=&fetchadminclasses_from_school(); 
&print_list("The list of every AdminClass:",@klassen);

# Subclasses
&titel("Creating list of every AdminClass with subclasses...");
#my @klassen_sub=&get_adminclasses_sub_school(); 
my @klassen_sub=&fetchsubclasses_from_school(); 
&print_list("The list of every AdminClass with subclasses:",@klassen_sub);

# Projects
&titel("Creating list of every Project ...");
#my @projects=&get_projects_school(); 
my @projects=&fetchprojects_from_school(); 
&print_list("The list of every Project:",@projects);


# Räume
&titel("Creating list of every room ...");
#my @raeume=&get_raeume_in_schule(); 
my @raeume=&fetchrooms_from_school(); 
&print_list("The list of every room:",@raeume);



# Userlisten

# schueler
&titel("Creating list of every pupil ...");
#my @schueler=&get_pupils_school();
my @schueler=&fetchstudents_from_school();
&print_list("The list of every pupil:",@schueler);



# lehrer
&titel("Creating list of every teacher ...");
#my @lehrer=&get_lehrer_in_schule();
my @lehrer=&fetchstudents_from_adminclass(${DevelConf::teacher});
&print_list("The list of every teacher:",@lehrer);

# workstations
&titel("Creating list of every workstation ...");
#my @workstations=&get_workstations_in_schule();
#my @workstations=&get_workstations_school();
my @workstations=&fetchworkstations_from_school();
&print_list("The list of every workstation:",@workstations);


# --permissions
if ($dateirechte==1 or $info==1) {
   &repair_directories();
   exit;
}



################################################################################
# Erzeugt für jede Zeile von repair.directories einen Befehl
################################################################################
sub repair_directories {

   # Liste mit einem Element, dass die Schleifen EINMAL durchlaufen werden
   my @gruppen=("");
   my @user=("");
   my $num=0;
   if ($info==1){
      print "\nThe following commands can be selected with the option\n",
            "    --command-number number\n",
            "Otherwise all commands are executed (this takes time)\n\n";
   }
   open(DIRS, "<${repair_directories}")|| die "Fehler: $!";
   while (<DIRS>) {
       my $gruppen_anzahl=0;
       my $user_anzahl=0;
       chomp();   
       if ($_ eq ""){next;} # Wenn Zeile Leer, dann aussteigen
       if(/^\#/){next;} # Bei Kommentarzeichen aussteigen

       $num++;
       # replace the first occurence of the string $homedir... 
       # with the value of the variable $homedir...

       #s/\$homedir_admin/$DevelConf::homedir_admin/;
       s/\$var_lib_pfad/$DevelConf::var_lib_pfad/;
       s/\$homedir_all_admins/$DevelConf::homedir_all_admins/;
       s/\$homedir_pupil/${DevelConf::homedir_pupil}/;     
       s/\$homedir_teacher/$DevelConf::homedir_teacher/; 
       s/\$homedir_ws/$DevelConf::homedir_ws/; 

       # order is important($homedir_samba must be replaced at last)    
       s/\$homedir_samba_cds/$DevelConf::homedir_samba_cds/;     
       s/\$homedir_samba_netlogon/$DevelConf::homedir_samba_netlogon/;     
       s/\$homedir_samba_progs/$DevelConf::homedir_samba_progs/;     
       s/\$homedir_samba/$DevelConf::homedir_samba/;     

       s/\$share_exams/$DevelConf::share_exams/;     
       s/\$share_teacher/$DevelConf::share_teacher/;     
       s/\$share_school/$DevelConf::share_school/;     


       s/\$share_share/$DevelConf::share_share/;     
       s/\$share_classes/$DevelConf::share_classes/;     
       s/\$share_subclasses/$DevelConf::share_subclasses/;     
       s/\$share_projects/$DevelConf::share_projects/;     

       s/\$tasks_tasks/$DevelConf::tasks_tasks/;
       s/\$tasks_teachers/$DevelConf::tasks_teachers/;     
       s/\$tasks_classes/$DevelConf::tasks_classes/;     
       s/\$tasks_subclasses/$DevelConf::tasks_subclasses/;     
       s/\$tasks_projects/$DevelConf::tasks_projects/;     
       s/\$tasks_rooms/$DevelConf::tasks_rooms/;     

       s/\$share_dir/$Language::share_dir/;     
       s/\$task_dir/$Language::task_dir/;     
       s/\$to_handoutcopy_dir/$Language::to_handoutcopy_dir/;     
       s/\$handout_dir/$Language::handout_dir/;     
       s/\$handoutcopy_dir/$Language::handoutcopy_dir/;     
       s/\$exam/$Language::exam/;     
       s/\$collect_dir/$Language::collect_dir/;     
       s/\$collected_dir/$Language::collected_dir/;     
       s/\$current_room/$Language::current_room/;     
       
       # print only number of command when --info
       if ($info==1){
           print "Nr. $num: $_\n";
	   next;
       }

       # act only on specific lines
       if ($command_number!=0 and $command_number!=$num){
           next;    
       }

       # show what command is processed
       &titel("Command number ${num}:");
       print "$_\n";


       # Zeile zerlegen
       my ($path, $owner, $groupowner, $permission) = split(/::/);

       # Gruppen auswählen
       if (/\$klassen/) {
           # Liste ist Klassenliste
           @gruppen=@klassen;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$klassen gefunden (Gruppenplatzhalter: $gruppen_anzahl)\n";
           }
       }elsif (/\$raeume/) {
           # Liste ist Raumliste
           @gruppen=@raeume;
           $gruppen_anzahl++;
           if($Conf::log_level>=3){
              print "\$raeume found (Group: $gruppen_anzahl)\n";
	   }
       } else {
           if($Conf::log_level>=3){
              print ("No \$klassen or \$raeume found (Group: $groupowner)\n");
           }
           @gruppen=($groupowner);
       }

       # Abbruch, falls verschiedene Gruppenplatzhalter
       if ($gruppen_anzahl > 1){
             print "\nFehler: Gruppen-Platzhalter-Anzahl $gruppen_anzahl.",
                   " ABBRUCH.\n\n";
             exit;
       }

       # User auswählen
       if ($path=~/\$schueler/) {
           if($Conf::log_level>=3){
              print "\$schueler found (Schülerliste)\n";
	   }
           # Liste ist Schülerliste
           @user=@schueler;
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$schueler found (Userplatzhalter: $user_anzahl)\n";
	   }
       } elsif (/\$lehrer/) {
           # Liste ist Lehrerliste
           @user=@lehrer;
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$lehrer found (Userplatzhalter: $user_anzahl)\n";
	   }
       }elsif (/\$workstation/) {
           # Liste ist Workstationliste
           @user=@workstations;
           $user_anzahl++;
           if($Conf::log_level>=3){
              print "\$workstation found (Userplatzhalter: $user_anzahl)\n";
	   }
       } else {
           if($Conf::log_level>=3){
              print ("No \$schueler, \$lehrer or \$workstations found ");
              print ("(Userplatzhalter: $owner)\n");
	   }
           @user=($owner);
       }

       # Abbruch, falls verschiedene Userplatzhalter
       if ($user_anzahl > 1){
             print "\nFehler: User-Platzhalter-Anzahl:  $user_anzahl. ABBRUCH.\n\n";
             exit;
       }
         
       # Verzeichnis reparieren
       if($Conf::log_level>=3){
          print "   Aufruf von &repair_directory mit:\n";
          print "     Pfad:         $path\n";
          print "     Owner:        $owner\n";
          print "     Gruppe:       $groupowner\n";
          print "     Rechte:       $permission\n";
          print "     Gruppenliste: @gruppen\n";
          print "     Userliste:    @user\n";
       }
       &repair_directory($path, $owner, $groupowner, $permission, \@gruppen, \@user);
   }

   close(DIRS);
}



################################################################################
# REparieren eines Verzeichnisses 
################################################################################
sub repair_directory {
   # Übergabewerte:
   # pfad(string) mit variablen $gruppe und $user
   # owner(name)
   # gruppenowner(name)
   # Dateirechte(octal, z.B. 0775)
   # Referenz auf gruppen (evtl. auch leere liste)
   # Referenz auf user (evtl. auch leere liste)

   # Übergabewerte zuweisen
   my ($path, $owner, $groupowner, $permission, $gruppen, $user) = @_;

   my $korrigieren=1;
   my $permission_to_set="";
   # Allgemeine Ersetzungen
   # $webserver
   $path=~s/\/\$webserver/$DevelConf::apache_root/;
   # $webuser
   $owner=~s/\$webuser/$DevelConf::apache_user/;
   # $samba
#   $path=~s/\/\$samba/$DevelConf::samba_dir/;
   my @userliste=();

   if($Conf::log_level>=3){
      print "Pfad mit Ersetzungen: $path\n";
   }

   foreach $gruppe (@$gruppen){
         if($Conf::log_level>=3){
            print "***** Gruppe ist $gruppe *****\n";
         }
         # Pfad sichern
         my $save_path=$path;
         # Owner sichern
         my $save_owner=$owner; 

         # Group-owner sichern
         my $save_groupowner=$groupowner; 

         # Userliste evtl. einschränken
	 if ($path=~/\$klassen/ && $path=~/\$schueler/) {
#            @userliste=&get_schueler_in_klasse($gruppe);
            @userliste=&fetchstudents_from_adminclass($gruppe);
            #print "Userliste: Nur Klasse\n";
	 } elsif ($path=~/\$raeume/ && $path=~/\$workstation/) {
#            @userliste=&get_workstations_in_raum($gruppe);
            @userliste=&fetchworkstations_from_room($gruppe);
            #print "Userliste: Nur Workstations\n";
	 } else {
            my $zahl=@$user;
            if (not $zahl==0) {
               @userliste=@$user;
               #print "Userliste: Alle ($zahl)\n";
	    } else {
               @userliste=("");
               print "Userliste: User ohne Namen ($zahl User)\n";
	    }
	 }

         # Ersetzungen vornehmen von Gruppen
         # Bsp.: String $klassen mit dem Wert von $gruppe ersetzen
         $path=~s/\$klassen/$gruppe/g; 
         $path=~s/\$raeume/$gruppe/g; 

         $groupowner=~s/\$klassen/$gruppe/g; 
         $groupowner=~s/\$raeume/$gruppe/g;

      foreach $user (@userliste){
         if($Conf::log_level>=3){
            print "User ist $user\n";
         }
         # Pfad sichern
         my $save_path=$path;         
         # Owner sichern
         my $save_owner=$owner;
         
         # Grou-owner sichern
         my $save_groupowner=$groupowner;
         
         my $ownerid=0;
         my $gid=0;

         # Ersetzungen vornehmen von Usern
         $path=~s/\$schueler/$user/g; 
         $path=~s/\$lehrer/$user/g; 
         $path=~s/\$workstation/$user/g; 

         $owner=~s/\$schueler/$user/g; 
         $owner=~s/\$lehrer/$user/g;
         $owner=~s/\$workstation/$user/g; 

         if (not defined ($ownerid = getpwnam $owner)) {
            print "Benutzer $owner gibt es nicht!\n";
            next;
         }

         if (not   defined ($gid = getgrnam $groupowner)) {
            print "Gruppe $groupowner gibt es nicht!\n";
            next;
         }

         # Anlegen, falls nicht vorhanden
         # folgendes nicht mehr verwenden, da rechte unötigerweise verändert werden
         #system("install -d $path");
 
         if (not -e $path) {
            # anlegen
            mkdir $path;
            #mkdir $path, oct($permission);
         }
         # # Mehrere mit / getrente Permissions angegeben -> Liste
         if ($permission =~m/\//) {
             my @permission_list = split(/\//,$permission);
             # Dateirechte des Verzeichnises ermitteln
             my ($a,$b,$mode) = stat(${path});
             #print "Mode ist $mode\n";
             # Umwandeln in übliche Schreibweise
             $mode &=07777;
             $mode=sprintf "%04o",$mode;

             if($Conf::log_level>=2){
                print "Permissions are $mode  (Permitted: $permission)\n";
	     }
             # Falls Verzeichnisrechte gesetzt werden müssen, 
             # auf den ersten Wert setzten 
             $permission_to_set=$permission_list[0];
             # Sind die Verzeichnisrechte OK
	     foreach my $perm (@permission_list){
               if ($mode==$perm) {
               #print "VerzeichnisrechteOK\n";
               # Verzeichnisrechte wurden in der Liste der zulässigen gefunden
               # -> nicht mehr korrigieren
               $korrigieren=0;
               }
             }
         } else {
           $permission_to_set=$permission;
         }

         # Bei Bedarf Verzeichnisrechte korrigieren
         if ($korrigieren==1) {
            chmod oct($permission_to_set), $path;
            chown $ownerid, $gid, $path;
            print "  * $path $owner($ownerid) ",
                  "$groupowner($gid) $permission_to_set\n";
         } else {
            # Verzeichnisrechte nicht korrigieren
            chown $ownerid, $gid, $path;
            print "  * $path $owner($ownerid) ",
                  "$groupowner($gid) Rechte: OK\n";
            # Korrigier-Variable zurücksetzten
            $korrigieren=1;
	 }

         # Pfad wiederherstellen
         $path=$save_path;
         $owner=$save_owner;
         $groupowner=$save_groupowner;
      }

    # Pfad wiederherstellen
    $path=$save_path;
    $owner=$save_owner;
    $groupowner=$save_groupowner;
    }

}



